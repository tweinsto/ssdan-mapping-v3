# explore vars 
```{r}

acs_vars <- load_variables(2023, "acs1", cache = TRUE)

# Filter for variables starting with B11005
vars <- acs_vars %>%
  filter(grepl("^B25075", name))

# 
#  inv_income = "B19054_002",  # Households with interest/dividends/rent income
#     inv_total = "B19054_001",
#     homeval_2mil = "B25075_027",
#     homeval_total = "B25075_001",
#     vehicles_total = "B08201_001",
#     vehicles_3plus = "B08201_005"

```



# EARNINGS
```{r}

library(tidycensus)
library(dplyr)
library(sf)
library(stringr)
library(leaflet)
library(RColorBrewer)
library(htmlwidgets)
library(tigris)


# GET DATA 
percap_data <- get_acs(
  geography = "state",
  variables = "B19301_001",  # Per capita income
  year = 2023,
  survey = "acs5",
  geometry = TRUE,
  cache_table = TRUE,
  cb = TRUE
) %>%
  rename(percap = estimate, state_fips = GEOID) %>%
  mutate(link = paste0("earnings-pages/", state_fips, ".html")) %>%
  st_transform(4326)

# -------------------- STEP 2: SHIFT GEOMETRY --------------------
shift_geometry <- function(sf_obj) {
  alaska <- sf_obj %>% filter(state_fips == "02") %>% st_transform(2163)
  hawaii <- sf_obj %>% filter(state_fips == "15") %>% st_transform(2163)
  mainland <- sf_obj %>% filter(!state_fips %in% c("02", "15")) %>% st_transform(4326)
  alaska_geom <- st_geometry(alaska) * 0.3 + c(-380000, -3000000)
  hawaii_geom <- st_geometry(hawaii) * 1.2 + c(4500000, -900000)
  st_crs(alaska_geom) <- 2163; st_crs(hawaii_geom) <- 2163
  alaska <- st_set_geometry(alaska, alaska_geom) %>% st_transform(4326)
  hawaii <- st_set_geometry(hawaii, hawaii_geom) %>% st_transform(4326)
  bind_rows(mainland, alaska, hawaii) %>% st_as_sf()
}

percap_data <- shift_geometry(percap_data)

# -------------------- STEP 3: WHITE MASK --------------------
world_box <- st_as_sfc(st_bbox(c(xmin = -180, ymin = -90, xmax = 180, ymax = 90)), crs = 4326)
us_box <- st_as_sfc(st_bbox(c(xmin = -130, ymin = 15, xmax = -60, ymax = 55)), crs = 4326)
world_box <- st_make_valid(world_box)
us_box <- st_make_valid(us_box)
mask_diff <- st_difference(world_box, us_box)
mask_polygon <- st_collection_extract(mask_diff, "POLYGON")
st_crs(mask_polygon) <- 4326
mask_polygon <- st_make_valid(mask_polygon)
mask_polygon <- st_transform(mask_polygon, 4326)

# -------------------- STEP 4: COLOR PALETTE --------------------
valid_vals <- percap_data$percap[!is.na(percap_data$percap) & percap_data$percap > 0]
breaks <- pretty(valid_vals, n = 8)
colors <- colorRampPalette(brewer.pal(9, "BuGn"))(length(breaks) - 1)
pal <- colorBin(palette = colors, domain = valid_vals, bins = breaks)

# -------------------- STEP 5: LEAFLET MAP --------------------
percap_map <- leaflet(options = leafletOptions(
  minZoom = 4, maxZoom = 4,
  zoomControl = FALSE,
  dragging = FALSE,
  scrollWheelZoom = FALSE,
  doubleClickZoom = FALSE
)) %>%
  addTiles(urlTemplate = "") %>%

  # White background and mask
  addRectangles(-180, -90, 180, 90, fillColor = "white", fillOpacity = 1, stroke = FALSE) %>%
  addPolygons(data = mask_polygon, fillColor = "white", color = "white", weight = 0, fillOpacity = 1) %>%

  # State polygons with hover and click
  addPolygons(
    data = percap_data,
    fillColor = ~pal(percap),
    color = "white", weight = 0.5, fillOpacity = 0.9,
    label = ~paste0(NAME, ": $", formatC(percap, format = "f", digits = 0, big.mark = ",")),
    layerId = ~link,
    highlightOptions = highlightOptions(weight = 1, color = "black", bringToFront = TRUE)
  ) %>%

  # Legend with every 2nd label blanked
  addLegend(
    position = "topright",
    colors = colors,
    labels = {
      lbls <- paste0("$", formatC(breaks[-length(breaks)], format = "f", digits = 0, big.mark = ","))
    },
    title = "Per Capita Income",
    opacity = 1
  ) %>%
  setView(lng = -98.5, lat = 39.8, zoom = 4)

# -------------------- STEP 6: CLICK BEHAVIOR --------------------
percap_map <- onRender(percap_map, "
  function(el, x) {
    var map = this;
    var hash = window.location.hash;
    map.eachLayer(function(layer) {
      if (layer.options && layer.options.layerId) {
        layer.on('click', function(e) {
          window.top.location.href = layer.options.layerId + hash;
        });
      }
    });
  }
")

# -------------------- STEP 7: SAVE --------------------
saveWidget(
  widget = percap_map,
  file = '/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/earnings.html',
  selfcontained = FALSE
)





# CREATE STATE MAPS

unique_states <- unique(earnings_data$state_fips)
# ----- Download all county per capita data -----
percap_all <- map_dfr(states, function(st) {
  get_acs(
    geography = "county",
    variables = "B19301_001",  # Per capita income
    state = st,
    year = year,
    survey = "acs5",
    geometry = TRUE,
    cache_table = TRUE,
    cb = TRUE
  )
}) %>%
  rename(percap = estimate) %>%
  mutate(state_fips = str_sub(GEOID, 1, 2)) %>%
  st_transform(4326)

# ----- Generate 1 map per state -----
unique_states <- unique(percap_all$state_fips)

walk(unique_states, function(fips) {
  state_data <- percap_all %>% filter(state_fips == fips)

  if (nrow(state_data) == 0 || all(is.na(state_data$geometry))) return(NULL)
# 
# Create click target: county HTML page
state_data <- state_data %>%
  mutate(link = paste0("../count-pages/", GEOID, ".html"))

  # Color palette setup
  vals <- state_data$percap
  range_vals <- range(vals, na.rm = TRUE)
  breaks <- pretty(range_vals, 10)
  if (length(breaks) < 2) {
    breaks <- seq(floor(range_vals[1]), ceiling(range_vals[2]), length.out = 6)
  }
  palette_colors <- colorRampPalette(brewer.pal(9, "YlGnBu"))(length(breaks) - 1)
  pal <- colorBin(palette = palette_colors, domain = vals, bins = breaks, na.color = "#ccc")

  # Build map
  leaflet_map <- leaflet(state_data, options = leafletOptions(minZoom = 5, maxZoom = 8)) %>%
    addProviderTiles("CartoDB.PositronNoLabels") %>%
    addPolygons(
      fillColor = ~pal(percap),
      fillOpacity = 0.9,
      color = "white",
      weight = 0.7,
      label = ~paste0(NAME, ": $", formatC(percap, format = "f", digits = 0, big.mark = ",")),
      layerId = ~link,  # clickable
      highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
    ) %>%
    addLegend(
      position = "topright",
      pal = pal,
      values = vals,
      title = "Per Capita Income",
      opacity = 1,
      labFormat = labelFormat(prefix = "$", big.mark = ",")
    ) %>%
    onRender("
  function(el, x) {
    var map = this;
    map.eachLayer(function(layer) {
      if (layer.options && layer.options.layerId) {
        layer.on('click', function(e) {
          window.top.location.href = layer.options.layerId;  // ✅ full page redirect
        });
      }
    });
  }
")


  # Step 4: Save
  saveWidget(
    widget = leaflet_map,
    file = file.path(
      "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/earnings-maps/",
      paste0(fips, ".html")
    ),
    selfcontained = FALSE
  )

  cat("✅ Saved:", fips, "\n")
})


# county maps !! 

school_income <- get_acs(
  geography = "school district (unified)",
  variables = "B19301_001",  # Per capita income
  year = 2023,
  survey = "acs5",
  geometry = TRUE,
  cache_table = TRUE
) %>%
  rename(percap = estimate) %>%
  select(GEOID, NAME, percap, geometry) %>%
  st_transform(4326)

# ------------------ Step 2: Get County FIPS ------------------
# We'll extract the county FIPS code from the district GEOID
# For school districts, GEOID = state (2) + district (5), but we need counties separately
# So instead, we'll use spatial intersection to assign counties

# Load counties
counties_sf <- counties(cb = TRUE, year = 2023) %>%
  filter(!STATEFP %in% c("72", "78")) %>%  # remove Puerto Rico etc.
  st_transform(4326) %>%
  select(county_fips = GEOID, county_name = NAME)

# Spatial join: assign each school district to the county it overlaps most
districts_with_county <- st_join(
  school_income,
  counties_sf,
  join = st_intersects,
  left = FALSE
)


# ------------------ Step 3: Loop by County ------------------
unique_counties <- unique(districts_with_county$county_fips)

walk(unique_counties, function(fips) {
  county_data <- districts_with_county %>%
    filter(county_fips == fips)

  if (nrow(county_data) == 0 || all(is.na(county_data$geometry))) return(NULL)

  vals <- county_data$percap
  range_vals <- range(vals, na.rm = TRUE)

  # Generate breaks
  breaks <- pretty(range_vals, 10)
  breaks <- unique(breaks)

  if (length(breaks) < 2) {
    breaks <- seq(floor(range_vals[1]), ceiling(range_vals[2]), length.out = 6)
  }

  palette_colors <- colorRampPalette(brewer.pal(9, "YlGnBu"))(length(breaks) - 1)
  pal <- colorBin(palette = palette_colors, domain = vals, bins = breaks, na.color = "#ccc")

  # Build map
  leaflet_map <- leaflet(county_data, options = leafletOptions(minZoom = 6, maxZoom = 10)) %>%
    addProviderTiles("CartoDB.PositronNoLabels") %>%
    addPolygons(
      fillColor = ~pal(percap),
      fillOpacity = 0.9,
      color = "white",
      weight = 1,
      label = ~paste0(NAME, ": $", formatC(percap, format = "f", digits = 0, big.mark = ",")),
      highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
    ) %>%
    addLegend(
      position = "topright",
      pal = pal,
      values = vals,
      title = "Per Capita Income",
      opacity = 1,
      labFormat = labelFormat(prefix = "$", big.mark = ",")
    )

  # Save map by county FIPS
  saveWidget(
    widget = leaflet_map,
    file = file.path(
      "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/school-maps/",
      paste0(fips, ".html")
    ),
    selfcontained = FALSE
  )

  cat("✅ Saved:", fips, "\n")
})


library(fs)
library(glue)
library(readr)
library(stringr)
library(fs)
library(glue)
library(readr)
library(stringr)

input_map_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/earnings-maps"
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/earnings-pages/"
input_table_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/ineq-widgets"

# List HTML files
fips_list <- dir_ls(input_map_dir, regexp = "\\.html$") %>% path_file() %>% path_ext_remove()

walk(fips_list, function(fips_code) {
  table_path <- file.path(input_table_dir, paste0(fips_code, ".html"))
  map_src <- glue("../earnings-maps/{fips_code}.html")

  # Read just the <table> from the existing HTML file

  html_content <- glue('
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Per Capita Earnings – State {fips_code}</title>
  <style>
    body {{
      margin: 0;
      padding: 2rem;
      font-family: sans-serif;
      background-color: #f9f9f9;
    }}
    h1 {{
      font-size: 1.5rem;
      margin-bottom: 1.5rem;
    }}
    .container {{
      display: flex;
      gap: 2rem;
    }}
    .map {{
      flex: 1;
    }}
    .table-box {{
      flex: 1;
      background-color: white;
      padding: 1rem;
      border: 1px solid #ccc;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      overflow-x: auto;
    }}
    iframe {{
      width: 100%;
      height: 550px;
      border: none;
    }}
    table {{
      font-size: 0.95rem;
      border-collapse: collapse;
      width: 100%;
    }}
    th, td {{
      padding: 6px;
      border: 1px solid #ccc;
      text-align: left;
    }}
    th {{
      background-color: #f0f0f0;
    }}
  </style>
</head>
<body>

  <h1>County-Level Per Capita Earnings – {fips_code} (2023)</h1>
    <h5>Click a County to explore further! </h5>

  <div class="container">
    <div class="map">
      <iframe src="{map_src}" title="Median Earnings Map – {fips_code}"></iframe>
    </div>
    <div class="table-box">
      <div><strong>Statistics by County Table</strong></div>
      <iframe src="../facts-tables/{fips_code}.html" title=" Earnings Table – {fips_code}"></iframe>
    </div>
  </div>

</body>
</html>
')

  write_file(html_content, path(output_dir, paste0(fips_code, ".html")))
})

```
# POVERTY
```{r}


poverty_data <- get_acs(
  geography = "county",
  variables = c(poverty = "B17001_002", total = "B17001_001"),
  year = 2023,
  survey = "acs5",
  geometry = TRUE,
  cache_table = TRUE,
  cb = TRUE
) %>%
  select(GEOID, NAME, variable, estimate, geometry) %>%
  pivot_wider(names_from = variable, values_from = estimate) %>%
  mutate(
    percent_poverty = 100 * poverty / total,
    state_fips = str_sub(GEOID, 1, 2)
  ) %>%
  st_transform(4326)

# -------------------- STEP 2: STATE GEOMETRY + SHIFT FUNCTION --------------------
state_geom <- states(cb = TRUE, year = 2023) %>%
  filter(!STATEFP %in% c("72", "78")) %>%
  select(state_fips = STATEFP, geometry) %>%
  mutate(link = paste0("poverty-pages/", state_fips, ".html"))

shift_geometry <- function(sf_obj) {
  alaska <- sf_obj %>% filter(state_fips == "02") %>% st_transform(2163)
  hawaii <- sf_obj %>% filter(state_fips == "15") %>% st_transform(2163)
  mainland <- sf_obj %>% filter(!state_fips %in% c("02", "15")) %>% st_transform(4326)
  alaska_geom <- st_geometry(alaska) * 0.3 + c(-380000, -3000000)
  hawaii_geom <- st_geometry(hawaii) * 1.2 + c(4500000, -900000)
  st_crs(alaska_geom) <- 2163; st_crs(hawaii_geom) <- 2163
  alaska <- st_set_geometry(alaska, alaska_geom) %>% st_transform(4326)
  hawaii <- st_set_geometry(hawaii, hawaii_geom) %>% st_transform(4326)
  bind_rows(mainland, alaska, hawaii) %>% st_as_sf()
}

state_geom <- shift_geometry(state_geom)
poverty_shifted <- shift_geometry(poverty_data)

# -------------------- STEP 3: WHITE MASK --------------------
world_box <- st_as_sfc(st_bbox(c(xmin = -180, ymin = -90, xmax = 180, ymax = 90)), crs = 4326)
us_box <- st_as_sfc(st_bbox(c(xmin = -130, ymin = 15, xmax = -60, ymax = 55)), crs = 4326)
world_box <- st_make_valid(world_box)
us_box <- st_make_valid(us_box)
mask_diff <- st_difference(world_box, us_box)
mask_polygon <- st_collection_extract(mask_diff, "POLYGON")
st_crs(mask_polygon) <- 4326
mask_polygon <- st_make_valid(mask_polygon)
mask_polygon <- st_transform(mask_polygon, 4326)

# -------------------- STEP 4: COLOR PALETTE --------------------
valid_vals <- poverty_data$percent_poverty[!is.na(poverty_data$percent_poverty) & poverty_data$percent_poverty > 0]
breaks <- pretty(valid_vals, n = 6)
colors <- colorRampPalette(brewer.pal(9, "Reds"))(length(breaks) - 1)
pal <- colorBin(palette = colors, domain = valid_vals, bins = breaks)

# -------------------- STEP 5: LEAFLET MAP --------------------
poverty_map <- leaflet(options = leafletOptions(
  minZoom = 4, maxZoom = 4,
  zoomControl = FALSE,
  dragging = FALSE,
  scrollWheelZoom = FALSE,
  doubleClickZoom = FALSE
)) %>%

  # Blank tile layer (no basemap)
  addTiles(urlTemplate = "") %>%

  # Add white rectangle covering the entire map
  addRectangles(
    lng1 = -180, lat1 = -90,
    lng2 = 180, lat2 = 90,
    fillColor = "white",
    fillOpacity = 1,
    stroke = FALSE
  ) %>%

  # Add US mask (if you want cleaner edges)
  addPolygons(data = mask_polygon, fillColor = "white", color = "white", weight = 0, fillOpacity = 1) %>%

  # County fill
  addPolygons(
    data = poverty_shifted,
    fillColor = ~pal(percent_poverty),
    color = "white", weight = 0.3, fillOpacity = 0.9,
    label = ~paste0(NAME, ": ", round(percent_poverty, 1), "%"),
    highlightOptions = highlightOptions(weight = 1, color = "black", bringToFront = TRUE)
  ) %>%

  # State click outlines
  addPolygons(
    data = state_geom,
    fillOpacity = 0,
    color = "black",
    weight = 1,
    layerId = ~link,
    highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
  ) %>%

  # Legend
  addLegend(
    position = "topright",
    colors = colors,
    labels = paste0(formatC(breaks[-length(breaks)], format = "d"), "%"),
    title = "% in Poverty",
    opacity = 1
  ) %>%

  setView(lng = -98.5, lat = 39.8, zoom = 8)

# -------------------- STEP 6: CLICK BEHAVIOR --------------------
poverty_map <- onRender(poverty_map, "
  function(el, x) {
    var map = this;
    var hash = window.location.hash;
    map.eachLayer(function(layer) {
      if (layer.options && layer.options.layerId) {
        layer.on('click', function(e) {
          window.top.location.href = layer.options.layerId + hash;
        });
      }
    });
  }
")

library(htmltools)

# Wrap the title + map together




# -------------------- STEP 7: SAVE --------------------
saveWidget(
  widget = poverty_map,
  file = '/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/poverty.html',
  selfcontained = FALSE
) 









walk(unique_states, function(fips) {
  state_data <- poverty_data %>%
    filter(state_fips == fips)

  if (nrow(state_data) == 0 || all(is.na(state_data$geometry))) return(NULL)

  # Step 1: Determine data range for this state
  range_vals <- range(state_data$percent_poverty, na.rm = TRUE)

  # Step 2: Generate "nice" breaks dynamically
 raw_breaks <- quantile(state_data$percent_poverty, probs = seq(0, 1, length.out = 6), na.rm = TRUE)
breaks <- pretty(raw_breaks)



  # Step 3: Create color palette function
  pal <- colorBin(
  palette = "Reds",
  domain = state_data$percent_poverty,
  bins = breaks,
  pretty = FALSE
)

  # Step 4: Build leaflet map
  leaflet_map <- leaflet(state_data, options = leafletOptions(minZoom = 4, maxZoom = 8)) %>%
    addProviderTiles("CartoDB.PositronNoLabels") %>%
    addPolygons(
      fillColor = ~pal(percent_poverty),
      fillOpacity = 0.9,
      color = "white",
      weight = 1,
      label = ~paste0(NAME, ": ", round(percent_poverty, 1), '%'),
      highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
    ) %>%
    addLegend(
      position = "topright",
      pal = pal,
      values = state_data$percent_poverty,
      title = "% of Population in Poverty",
      opacity = 1
    )

  # Step 5: Save map
  saveWidget(
    widget = leaflet_map,
    file = paste0(
      "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/pov-maps/",
      fips, ".html"
    ),
    selfcontained = FALSE
  )
})

# STATE PAGES

library(fs)
library(glue)
library(readr)
library(stringr)
library(fs)
library(glue)
library(readr)
library(stringr)

input_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/pov-maps"
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/pov-maps"

# List HTML files
html_files <- dir_ls(input_dir, regexp = "\\.html$")

walk(html_files, function(file_path) {
  fips_code <- path_file(file_path) %>% path_ext_remove()

  html_content <- glue('
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>% Poverty Map – State {fips_code}</title>
  <style>
    body {{
      margin: 0;
      padding: 1.5rem;
      font-family: sans-serif;
      background-color: #f2f2f2;
    }}
    h1 {{
      font-size: 1.3rem;
      margin-bottom: 1rem;
    }}
    .container {{
      display: flex;
      gap: 2rem;
    }}
    .map-column {{
      flex: 1;
    }}
    .sidebar {{
      flex: 1;
    }}
    iframe {{
      width: 100%;
      height: 600px;
      border: none;
    }}
    a#back-link {{
      display: inline-block;
      margin-bottom: 1rem;
      font-size: 0.95rem;
      color: #003366;
      text-decoration: none;
      font-weight: bold;
    }}
  </style>
</head>
<body>
  
  <h1>Poverty by County – State {fips_code}</h1>
  <div class="container">
    <div class="map-column">
      <iframe src="../pov-maps/{fips_code}.html" title="Map of State {fips_code}"></iframe>
    </div>
    <div class="sidebar">
      <!-- You can add text, links, charts, etc. here later -->
    </div>
  </div>
</body>
</html>
')

  write_file(html_content, path(output_dir, paste0(fips_code, ".html")))
})


```

# pov tables

```{r}

poverty_all <- map_dfr(states, ~{
  get_acs(
    geography = "county",
    variables = c(poverty = "B17001_002", total = "B17001_001"),
    state = .x,
    year = year,
    survey = "acs5"
  )
})

poverty_clean <- poverty_all %>%
  select(GEOID, NAME, variable, estimate) %>%
  pivot_wider(names_from = variable, values_from = estimate) %>%
  transmute(
    GEOID,
    NAME,
    pct_poverty = 100 * poverty / total
  )

# 5. Get state FIPS codes
state_fips_codes <- tidycensus::fips_codes %>%
  distinct(state, state_code) %>%
  filter(state %in% states) %>%
  arrange(state) %>%
  pull(state_code)

# 6. Output directory
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/facts-tables-pov/"
dir.create(output_dir, showWarnings = FALSE)

# 7. Create per-state tables
walk2(states, state_fips_codes, function(state_abbr, state_fips) {
  message("Processing: ", state_abbr)

  earnings <- earnings_all %>%
    filter(str_sub(GEOID, 1, 2) == state_fips) %>%
    select(GEOID, NAME, median_earnings = estimate)

  education <- education_all %>%
    filter(str_sub(GEOID, 1, 2) == state_fips) %>%
    group_by(GEOID, NAME) %>%
    summarize(
      pct_bachelor_plus = 100 * sum(estimate[variable != "total"]) / estimate[variable == "total"],
      .groups = "drop"
    )

  employment <- employment_clean %>%
    filter(str_sub(GEOID, 1, 2) == state_fips)

  poverty <- poverty_clean %>%
    filter(str_sub(GEOID, 1, 2) == state_fips)

  table_data <- poverty %>%
    left_join(earnings, by = c("GEOID", "NAME")) %>%
    left_join(education, by = c("GEOID", "NAME")) %>%
    left_join(employment, by = c("GEOID", "NAME")) %>%
    mutate(
      `% in Poverty` = round(pct_poverty, 1),
      `Median Earnings ($)` = dollar(median_earnings, accuracy = 1),
      `% Bachelor's+` = round(pct_bachelor_plus, 1),
      `% Full-Time` = round(pct_full_time, 1),
      County = NAME
    ) %>%
    select(
      County,
      `% in Poverty`,
      `Median Earnings ($)`,
      `% Bachelor's+`,
      `% Full-Time`
    )

  # Create DT widget
  dt_widget <- datatable(
    table_data,
    rownames = FALSE,
    options = list(
      pageLength = 25,
      autoWidth = TRUE,
      dom = 'tip',
      ordering = TRUE
    ),
    class = "stripe hover compact"
  )

  # Save widget
  saveWidget(
    dt_widget,
    file = file.path(output_dir, paste0(state_fips, ".html")),
    selfcontained = TRUE
  )
})

# write pov pages 


input_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/pov-maps"
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/poverty-pages"
image_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/facts-tables-pov/"

# List HTML files
html_files <- dir_ls(input_dir, regexp = "\\.html$")

walk(html_files, function(file_path) {
  fips_code <- path_file(file_path) %>% path_ext_remove()

  html_content <- glue('
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Poverty – State {fips_code}</title>
  <style>
    body {{
      margin: 0;
      padding: 1.5rem;
      font-family: sans-serif;
      background-color: #f2f2f2;
    }}
    h1 {{
      font-size: 1.3rem;
      margin-bottom: 1rem;
    }}
    .container {{
      display: flex;
      gap: 2rem;
    }}
    .map-column {{
      flex: 1;
    }}
    .sidebar {{
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }}
    iframe {{
      width: 100%;
      height: 600px;
      border: none;
    }}
    img {{
      max-width: 100%;
      height: auto;
      border: 1px solid #ccc;
      background: white;
      padding: 10px;
    }}
    a#back-link {{
      display: inline-block;
      margin-bottom: 1rem;
      font-size: 0.95rem;
      color: #003366;
      text-decoration: none;
      font-weight: bold;
    }}
  </style>
</head>
<body>
  
  <h1>Poverty by County – State {fips_code}</h1>
  <div class="container">
    <div class="map-column">
      <iframe src="../pov-maps/{fips_code}.html" title="Map of State {fips_code}"></iframe>
    </div>
    <div class="sidebar">
      <iframe src="../facts-tables-pov/{fips_code}.html" alt="Poverty & Economic Indicators by County" style="height: 1000px">
    </div>
  </div>
</body>
</html>
')

  write_file(html_content, path(output_dir, paste0(fips_code, ".html")))
})



```

# top 20 

```{r}

top20_data <- get_acs(
  geography = "state",
  variables = "B19081_005",  # Mean income of highest quintile (top 20%)
  year = 2023,
  survey = "acs5",
  geometry = TRUE,
  cache_table = TRUE,
  cb = TRUE
) %>%
  rename(top20_income = estimate, state_fips = GEOID) %>%
  mutate(link = paste0("top20-pages/", state_fips, ".html")) %>%
  st_transform(4326)

# -------------------- SHIFT GEOMETRY --------------------
shift_geometry <- function(sf_obj) {
  alaska <- sf_obj %>% filter(state_fips == "02") %>% st_transform(2163)
  hawaii <- sf_obj %>% filter(state_fips == "15") %>% st_transform(2163)
  mainland <- sf_obj %>% filter(!state_fips %in% c("02", "15")) %>% st_transform(4326)
  alaska_geom <- st_geometry(alaska) * 0.3 + c(-380000, -3000000)
  hawaii_geom <- st_geometry(hawaii) * 1.2 + c(4500000, -900000)
  st_crs(alaska_geom) <- 2163; st_crs(hawaii_geom) <- 2163
  alaska <- st_set_geometry(alaska, alaska_geom) %>% st_transform(4326)
  hawaii <- st_set_geometry(hawaii, hawaii_geom) %>% st_transform(4326)
  bind_rows(mainland, alaska, hawaii) %>% st_as_sf()
}

top20_data <- shift_geometry(top20_data)

# -------------------- MASK --------------------
world_box <- st_as_sfc(st_bbox(c(xmin = -180, ymin = -90, xmax = 180, ymax = 90)), crs = 4326)
us_box <- st_as_sfc(st_bbox(c(xmin = -130, ymin = 15, xmax = -60, ymax = 55)), crs = 4326)
world_box <- st_make_valid(world_box)
us_box <- st_make_valid(us_box)
mask_diff <- st_difference(world_box, us_box)
mask_polygon <- st_collection_extract(mask_diff, "POLYGON")
st_crs(mask_polygon) <- 4326
mask_polygon <- st_make_valid(mask_polygon)

# -------------------- COLOR PALETTE --------------------
valid_vals <- top20_data$top20_income[!is.na(top20_data$top20_income) & top20_data$top20_income > 0]
breaks <- pretty(valid_vals)
colors <- colorRampPalette(brewer.pal(9, "PuBuGn"))(length(breaks) - 1)
pal <- colorBin(palette = colors, domain = valid_vals, bins = breaks)

# -------------------- MAP --------------------
top20_map <- leaflet(options = leafletOptions(
  minZoom = 4, maxZoom = 4,
  zoomControl = FALSE,
  dragging = FALSE,
  scrollWheelZoom = FALSE,
  doubleClickZoom = FALSE
)) %>%
  addTiles(urlTemplate = "") %>%

  # White mask background
  addRectangles(-180, -90, 180, 90, fillColor = "white", fillOpacity = 1, stroke = FALSE) %>%
  addPolygons(data = mask_polygon, fillColor = "white", color = "white", weight = 0, fillOpacity = 1) %>%

  # State shapes
  addPolygons(
    data = top20_data,
    fillColor = ~pal(top20_income),
    color = "white", weight = 0.5, fillOpacity = 0.9,
    label = ~paste0(NAME, ": $", formatC(top20_income, format = "f", digits = 0, big.mark = ",")),
    layerId = ~link,
    highlightOptions = highlightOptions(weight = 1, color = "black", bringToFront = TRUE)
  ) %>%

  # Legend
  addLegend(
    position = "topright",
    colors = colors,
    labels = {
      lbls <- paste0("$", formatC(breaks[-length(breaks)], format = "f", digits = 0, big.mark = ","))
    },
    title = "Top 20% Mean Income",
    opacity = 1
  ) %>%
  setView(lng = -98.5, lat = 39.8, zoom = 4)

# -------------------- CLICK BEHAVIOR --------------------
top20_map <- onRender(top20_map, "
  function(el, x) {
    var map = this;
    var hash = window.location.hash;
    map.eachLayer(function(layer) {
      if (layer.options && layer.options.layerId) {
        layer.on('click', function(e) {
          window.top.location.href = layer.options.layerId + hash;
        });
      }
    });
  }
")

# -------------------- SAVE --------------------
saveWidget(
  widget = top20_map,
  file = '/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/top20.html',
  selfcontained = FALSE
)



top20_data <- get_acs(
  geography = "county",
  variables = "B19081_005",  # Mean income of highest quintile (top 20%)
  year = 2023,
  survey = "acs5",
  geometry = TRUE,
  cache_table = TRUE,
  cb = TRUE
) %>%
  select(GEOID, NAME, variable, top20_income = estimate, geometry) %>%
  mutate(state_fips = str_sub(GEOID, 1, 2)) %>%
  st_transform(4326)

# state maps 

unique_states <- unique(top20_data$state_fips)

walk(unique_states, function(fips) {
  state_data <- top20_data %>%
    filter(state_fips == fips)

  if (nrow(state_data) == 0 || all(is.na(state_data$geometry))) return(NULL)

  # Step 1: Get valid income range for this state
  range_vals <- range(state_data$top20_income, na.rm = TRUE)

  # Step 2: Create nice dynamic breaks using quantiles + pretty
  raw_breaks <- quantile(state_data$top20_income, probs = seq(0, 1, length.out = 6), na.rm = TRUE)
  breaks <- pretty(raw_breaks)

  # Step 3: Create color palette
  pal <- colorBin(
    palette = "PuBuGn",
    domain = state_data$top20_income,
    bins = breaks,
    pretty = FALSE
  )

  # Step 4: Create map
  leaflet_map <- leaflet(state_data, options = leafletOptions(minZoom = 5, maxZoom = 10)) %>%
    addProviderTiles("CartoDB.PositronNoLabels") %>%
    addPolygons(
      fillColor = ~pal(top20_income),
      fillOpacity = 0.9,
      color = "white",
      weight = 1,
      label = ~paste0(NAME, ": $", formatC(top20_income, format = "f", digits = 0, big.mark = ",")),
      highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
    ) %>%
    addLegend(
      position = "topright",
      pal = pal,
      values = state_data$top20_income,
      title = "Top 20% Mean Income",
      labFormat = labelFormat(prefix = "$", big.mark = ",", digits = 0),
      opacity = 1
    )

  # Step 5: Save map widget
  saveWidget(
    widget = leaflet_map,
    file = paste0(
      "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/top20-maps/",
      fips, ".html"
    ),
    selfcontained = FALSE
  )
})




# table 

counties <- get_acs(
  geography = "county",
  variables = c(
    inv_income = "B19054_002",  # Households with interest/dividends/rent income
    inv_total = "B19054_001",
    homeval_2mil = "B25075_027",
    homeval_1mil = "B25075_025",
    homeval_1.5mil = "B25075_026",
    homeval_total = "B25075_001",
    vehicles_total = "B08201_001",
    vehicles_3plus = "B08201_005"
  ),
  year = 2023,
  survey = "acs5"
) %>%
  select(GEOID, NAME, variable, estimate) %>%
  pivot_wider(names_from = variable, values_from = estimate) %>%
  mutate(
    pct_investment = 100 * inv_income / inv_total,
    pct_2mil_home = 100 * (homeval_2mil + homeval_1mil + homeval_1.5mil) / homeval_total,
    pct_3plus_vehicles = 100 * vehicles_3plus / vehicles_total
  ) %>%
  transmute(
    GEOID,
    NAME,
    `HH with Investment Income (%)` = round(pct_investment, 1),
    `HH with Home Value > $1M (%)` = round(pct_2mil_home, 1),
    `HH with 3+ Vehicles (%)` = round(pct_3plus_vehicles, 1)
  )

unique_states <- str_sub(counties$GEOID, 1, 2)

walk(unique(unique_states), function(fips) {
  state_data <- counties %>%
    filter(str_sub(GEOID, 1, 2) == fips)

  state_name <- unique(str_split_fixed(state_data$NAME[1], ", ", 2)[, 2])

  dt <- datatable(
    state_data %>% select(-GEOID),
    rownames = FALSE,
    options = list(pageLength = 25),
    caption = paste("Household Wealth Characteristics –", state_name)
  )

  saveWidget(
    dt,
    file = paste0("/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/top20-tables/", fips, ".html"),
    selfcontained = FALSE
  )
})


# state pages


input_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/top20-maps"
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/top20-pages"

# List HTML files
html_files <- dir_ls(input_dir, regexp = "\\.html$")

walk(html_files, function(file_path) {
  fips_code <- path_file(file_path) %>% path_ext_remove()

  html_content <- glue('
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Top 20% – State {fips_code}</title>
  <style>
    body {{
      margin: 0;
      padding: 1.5rem;
      font-family: sans-serif;
      background-color: #f2f2f2;
    }}
    h1 {{
      font-size: 1.3rem;
      margin-bottom: 1rem;
    }}
    .container {{
      display: flex;
      gap: 2rem;
    }}
    .map-column {{
      flex: 1;
    }}
    .sidebar {{
      flex: 1;
    }}
    iframe {{
      width: 100%;
      height: 600px;
      border: none;
    }}
    a#back-link {{
      display: inline-block;
      margin-bottom: 1rem;
      font-size: 0.95rem;
      color: #003366;
      text-decoration: none;
      font-weight: bold;
    }}
  </style>
</head>
<body>
  
  <h1>Top 20% Earners Mean Income by County – {fips_code}</h1>
  <div class="container">
    <div class="map-column">
      <iframe src="../top20-maps/{fips_code}.html" title="Map of State {fips_code}"></iframe>
    </div>
    <div class="sidebar">
      <iframe src="../top20-tables/{fips_code}.html" title="Map of State {fips_code}"></iframe>    </div>
  </div>
</body>
</html>
')

  write_file(html_content, path(output_dir, paste0(fips_code, ".html")))
})

```


# INCOME INEQUALITY
```{r}
library(tidycensus)
library(dplyr)
library(tidyr)
library(stringr)
library(sf)
library(leaflet)
library(RColorBrewer)
library(htmlwidgets)
library(htmltools)
library(tigris)
 






# INEQUALITY MAP

ineq_data <- get_acs(
  geography = "county",
  variables = c(
    bottom20 = "B19081_002",  # 1st quintile mean income
    top20 = "B19081_006"      # 5th quintile mean income
  ),
  year = 2023,
  survey = "acs5",
  geometry = TRUE,
  cb = TRUE,
  cache_table = TRUE
) %>%
  select(GEOID, NAME, variable, estimate, geometry) %>%
  pivot_wider(names_from = variable, values_from = estimate) %>%
  mutate(
    inequality_ratio = top20 / bottom20,

    state_fips = str_sub(GEOID, 1, 2)
  ) %>%
  filter(!is.na(inequality_ratio), bottom20 > 0, is.finite(inequality_ratio)) %>%
  st_transform(4326)

# -------------------- STEP 2: GET STATE GEOMETRY + SHIFT FUNCTION --------------------
state_geom <- states(cb = TRUE, year = 2023) %>%
  filter(!STATEFP %in% c("72", "78")) %>%
  select(state_fips = STATEFP, geometry) %>%
  mutate(link = paste0("ratio-pages/", state_fips, ".html"))

shift_geometry <- function(sf_obj) {
  alaska <- sf_obj %>% filter(state_fips == "02") %>% st_transform(2163)
  hawaii <- sf_obj %>% filter(state_fips == "15") %>% st_transform(2163)
  mainland <- sf_obj %>% filter(!state_fips %in% c("02", "15")) %>% st_transform(4326)
  alaska_geom <- st_geometry(alaska) * 0.3 + c(-380000, -3000000)
  hawaii_geom <- st_geometry(hawaii) * 1.2 + c(4500000, -900000)
  st_crs(alaska_geom) <- 2163; st_crs(hawaii_geom) <- 2163
  alaska <- st_set_geometry(alaska, alaska_geom) %>% st_transform(4326)
  hawaii <- st_set_geometry(hawaii, hawaii_geom) %>% st_transform(4326)
  bind_rows(mainland, alaska, hawaii) %>% st_as_sf()
}

state_geom <- shift_geometry(state_geom)
ineq_shifted <- shift_geometry(ineq_data)

# -------------------- STEP 3: WHITE MASK --------------------
world_box <- st_as_sfc(st_bbox(c(xmin = -180, ymin = -90, xmax = 180, ymax = 90)), crs = 4326)
us_box <- st_as_sfc(st_bbox(c(xmin = -130, ymin = 15, xmax = -60, ymax = 55)), crs = 4326)
mask_polygon <- st_difference(st_make_valid(world_box), st_make_valid(us_box))
mask_polygon <- st_collection_extract(mask_polygon, "POLYGON")
st_crs(mask_polygon) <- 4326
mask_polygon <- st_transform(mask_polygon, 4326)

# -------------------- STEP 4: COLOR PALETTE --------------------
valid_vals <- ineq_shifted$inequality_ratio[!is.na(ineq_shifted$inequality_ratio) & is.finite(ineq_shifted$inequality_ratio) & ineq_shifted$inequality_ratio > 0]
breaks <- pretty(valid_vals, n = 6)
colors <- colorRampPalette(brewer.pal(9, "Reds"))(length(breaks) - 1)
pal <- colorBin(palette = colors, domain = valid_vals, bins = breaks)

# -------------------- STEP 5: LEAFLET MAP --------------------
ratio_map <- leaflet(options = leafletOptions(
  minZoom = 4, maxZoom = 4,
  zoomControl = FALSE,
  dragging = FALSE,
  scrollWheelZoom = FALSE,
  doubleClickZoom = FALSE
)) %>%
  addTiles(urlTemplate = "") %>%
  addRectangles(
    lng1 = -180, lat1 = -90,
    lng2 = 180, lat2 = 90,
    fillColor = "white",
    fillOpacity = 1,
    stroke = FALSE
  ) %>%
  addPolygons(data = mask_polygon, fillColor = "white", color = "white", weight = 0, fillOpacity = 1) %>%
  addPolygons(
    data = ineq_shifted,
    fillColor = ~pal(inequality_ratio),
    color = "white", weight = 0.3, fillOpacity = 0.9,
    label = ~paste0(NAME, ": ", round(inequality_ratio, 2), "x"),
    highlightOptions = highlightOptions(weight = 1, color = "black", bringToFront = TRUE)
  ) %>%
  addPolygons(
    data = state_geom,
    fillOpacity = 0,
    color = "black",
    weight = 1,
    layerId = ~link,
    highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
  ) %>%
  addLegend(
    position = "topright",
    colors = colors,
    labels = paste0(round(breaks[-length(breaks)], 1), "x"),
    title = "Income Inequality Ratio",
    opacity = 1
  ) %>%
  setView(lng = -98.5, lat = 39.8, zoom = 8)

# -------------------- STEP 6: CLICK BEHAVIOR --------------------
ratio_map <- onRender(ratio_map, "
  function(el, x) {
    var map = this;
    var hash = window.location.hash;
    map.eachLayer(function(layer) {
      if (layer.options && layer.options.layerId) {
        layer.on('click', function(e) {
          window.top.location.href = layer.options.layerId + hash;
        });
      }
    });
  }
")

# -------------------- STEP 7: SAVE MAP --------------------
saveWidget(
  widget = ratio_map,
  file = '/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/ratio.html',
  selfcontained = FALSE
)







# TOP 20 STATE MAPS 

unique_states <- unique(top20_data$state_fips)

# Loop through each state
walk(unique(top20_data$state_fips), function(fips) {
  state_data <- top20_data %>%
    filter(state_fips == fips)

  if (nrow(state_data) == 0 || all(is.na(state_data$geometry))) return(NULL)

  # Step 1: Get valid top20 values
  vals <- state_data$top20
  vals <- vals[is.finite(vals) & vals > 0]

  if (length(unique(vals)) < 2) return(NULL)  # Skip states with flat values

  # Step 2: Use pretty breaks rounded to clean numbers
  breaks <- pretty(vals, n = 6)
  breaks <- unique(breaks)

  # Step 3: Build color palette
  colors <- colorRampPalette(brewer.pal(9, "Blues"))(length(breaks) - 1)
  pal <- colorBin(palette = colors, domain = vals, bins = breaks)

  # Step 4: Build map
  leaflet_map <- leaflet(state_data, options = leafletOptions(minZoom = 5, maxZoom = 8)) %>%
    addProviderTiles("CartoDB.PositronNoLabels") %>%
    addPolygons(
      fillColor = ~pal(top20),
      fillOpacity = 0.9,
      color = "white",
      weight = 1,
      label = ~paste0(NAME, ": $", formatC(top20, format = "d", big.mark = ",")),
      highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
    ) %>%
    addLegend(
      position = "topright",
      colors = colors,
      labels = paste0("$", formatC(breaks[-length(breaks)], format = "d", big.mark = ",")),
      title = "Top 20% Mean Income",
      opacity = 1
    )

  # Step 5: Save the map
  saveWidget(
    widget = leaflet_map,
    file = paste0(
      "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/top20-maps/",
      fips, ".html"
    ),
    selfcontained = FALSE
  )
})


# STATE PAGES 

library(fs)
library(glue)
library(readr)
library(stringr)
library(fs)
library(glue)
library(readr)
library(stringr)


# RATIO STATE MAPS

unique_states <- unique(ineq_data$inequality_ratio)

# Loop through each state
walk(unique(ineq_data$state_fips), function(fips) {
  state_data <- ineq_data %>%
    filter(state_fips == fips)

  if (nrow(state_data) == 0 || all(is.na(state_data$geometry))) return(NULL)

  # Step 1: Get valid top20 values
  vals <- state_data$inequality_ratio
  vals <- vals[is.finite(vals) & vals > 0]

  if (length(unique(vals)) < 2) return(NULL)  # Skip states with flat values

  # Step 2: Use pretty breaks rounded to clean numbers
  breaks <- pretty(vals, n = 6)
  breaks <- unique(breaks)

  # Step 3: Build color palette
  colors <- colorRampPalette(brewer.pal(9, "OrRd"))(length(breaks) - 1)
  pal <- colorBin(palette = colors, domain = vals, bins = breaks)

  # Step 4: Build map
  leaflet_map <- leaflet(state_data, options = leafletOptions(minZoom = 5, maxZoom = 8)) %>%
    addProviderTiles("CartoDB.PositronNoLabels") %>%
    addPolygons(
      fillColor = ~pal(inequality_ratio),
      fillOpacity = 0.9,
      color = "white",
      weight = 1,
      label = ~paste0(NAME, ": ", formatC(inequality_ratio, format = "d", big.mark = ","), 'x'),
      highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
    ) %>%
    addLegend(
      position = "topright",
      colors = colors,
      labels = paste0(formatC(breaks[-length(breaks)], format = "d", big.mark = ","), 'x'),
      title = "Income Inequality Ratio",
      opacity = 1
    )

  # Step 5: Save the map
  saveWidget(
    widget = leaflet_map,
    file = paste0(
      "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/ratio-maps/",
      fips, ".html"
    ),
    selfcontained = FALSE
  )
})


# write

library(fs)
library(glue)
library(readr)
library(stringr)

input_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/ratio-maps"
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/ratio-pages"
image_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/ineq-widgets/"

# List HTML files
html_files <- dir_ls(input_dir, regexp = "\\.html$")

walk(html_files, function(file_path) {
  fips_code <- path_file(file_path) %>% path_ext_remove()

  html_content <- glue('
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Income Inequality Ratio – State {fips_code}</title>
  <style>
    body {{
      margin: 0;
      padding: 1.5rem;
      font-family: sans-serif;
      background-color: #f2f2f2;
    }}
    h1 {{
      font-size: 1.3rem;
      margin-bottom: 1rem;
    }}
    .container {{
      display: flex;
      gap: 2rem;
    }}
    .map-column {{
      flex: 1;
    }}
    .sidebar {{
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }}
    iframe {{
      width: 100%;
      height: 600px;
      border: none;
    }}
    img {{
      max-width: 100%;
      height: auto;
      border: 1px solid #ccc;
      background: white;
      padding: 10px;
    }}
    a#back-link {{
      display: inline-block;
      margin-bottom: 1rem;
      font-size: 0.95rem;
      color: #003366;
      text-decoration: none;
      font-weight: bold;
    }}
  </style>
</head>
<body>
  
  <h1>Income Inequality Ratio by County – State {fips_code}</h1>
  <div class="container">
    <div class="map-column">
      <iframe src="../ratio-maps/{fips_code}.html" title="Map of State {fips_code}"></iframe>
    </div>
    <div class="sidebar">
      <iframe src="../ineq-widgets/{fips_code}.html" alt="Income Share Bar Chart for State {fips_code}" style="height: 800px">
    </div>
  </div>
</body>
</html>
')

  write_file(html_content, path(output_dir, paste0(fips_code, ".html")))
})



```


# avg earnings by occ widget
```{r}

library(tidycensus)
library(dplyr)
library(tidyr)
library(stringr)
library(jsonlite)
library(readr)
library(fs)

industry_vars <- c(
  "Agriculture" = "C24030_004",
  "Construction" = "C24030_005",
  "Manufacturing" = "C24030_006",
  "Retail" = "C24030_008",
  "Information" = "C24030_010",
  "Finance" = "C24030_011",
  "Education" = "C24030_013",
  "Public Admin" = "C24030_016"
)

# Pull from ACS
industry_workers <- get_acs(
  geography = "state",
  variables = industry_vars,
  year = 2023,
  survey = "acs5"
) 
industry_workers <- industry_workers %>% select(GEOID, state = NAME, variable, workers = estimate)

industry_pct <- industry_workers %>%
  group_by(state) %>%
  mutate(pct = round(100 * workers / sum(workers), 1)) %>%
  ungroup()

library(plotly)
industry_levels <- industry_pct %>%
  filter(state == "Alabama") %>%
  arrange(desc(pct)) %>%
  pull(variable)

industry_pct <- industry_pct %>%
  mutate(industry = factor(variable, levels = industry_levels))

# Color palette
industry_colors <- RColorBrewer::brewer.pal(n = length(industry_levels), name = "Set2")
names(industry_colors) <- industry_levels

# 3. Build traces by state
states <- unique(industry_pct$state)

traces <- lapply(states, function(st) {
  df <- industry_pct %>% filter(state == st)
  
  list(
    x = df$industry,
    y = df$pct,
    type = "bar",
    name = st,
    marker = list(color = industry_colors[as.character(df$industry)]),
    
    hoverinfo = "text",
    visible = ifelse(st == "Alabama", TRUE, FALSE)
  )
})

# 4. Dropdown buttons
buttons <- lapply(seq_along(states), function(i) {
  list(
    method = "update",
    label = states[i],
    args = list(
      list(visible = seq_along(states) == i),
      list(title = paste("Industry Distribution in", states[i]))
    )
  )
})

# 5. Build plot
fig <- plot_ly()
for (t in traces) {
  fig <- fig %>%
    add_trace(
      x = t$x,
      y = t$y,
      type = t$type,
      name = t$name,
      marker = t$marker,
      text = t$text,
      hoverinfo = t$hoverinfo,
      visible = t$visible
    )
}

# 6. Layout and dropdown positioning
fig <- fig %>%
  layout(
    title = list(
      text = "Industry Distribution in Alabama",
      y = 0.95  # Lower title just a bit to avoid clash
    ),
    margin = list(t = 80),  # Enough space for menu above plot
    xaxis = list(title = "Industry", tickangle = -45),
    yaxis = list(title = "Percent of Workforce"),
    showlegend = FALSE,
    updatemenus = list(list(
      buttons = buttons,
      direction = "down",
      showactive = TRUE,
      x = 0.3,
      y = 1.5,  # Move menu above the chart + below title
      xanchor = "center",
      yanchor = "top",
      xref = "paper",
      yref = "paper"
    ))
  ) %>%
  config(
    displayModeBar = FALSE,
  scrollZoom = FALSE,
  doubleClick = "reset",  # prevents zooming on double-click
  staticPlot = TRUE
  )


# 8. Save widget (no modebar, selfcontained = FALSE for faster load)
saveWidget(
  fig,
  "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/industry-widget.html",
  selfcontained = FALSE
)


```


# rent stress map 
```{r}


# Step 2: Get geometry
county_geom <- get_acs(
  geography = "county",
  variables = "B25070_001",  # dummy variable just to get geometry
  year = 2023,
  geometry = TRUE,
  cb = TRUE
) %>%
  select(GEOID, geometry)

rent_map_data <- rent_stress_df %>%
  left_join(county_geom, by = "GEOID") %>%
  filter(!is.na(pct_rent_burdened), is.finite(pct_rent_burdened)) %>%
  mutate(state_fips = substr(GEOID, 1, 2)) %>%
  st_as_sf()

# Step 3: Shift counties and states
rent_county_shifted <- shift_geometry(rent_map_data)

state_geom <- states(cb = TRUE, year = 2023) %>%
  filter(!STATEFP %in% c("72", "78")) %>%
  select(state_fips = STATEFP, geometry) %>%
  mutate(link = paste0("stress-pages/", state_fips, ".html")) %>%
  shift_geometry()

# Step 4: Define bins and palette for % rent-burdened
breaks <- c(0, 20, 30, 40, 50, 60)
colors <- c(
  "#ffffcc",  # 0–20% (low)
  "#ffeda0",  # 20–30%
  "#feb24c",  # 30–40%
  "#fd8d3c",  # 40–50%
  "#f03b20"   # 50–60%
)

pal <- colorBin(
  palette = colors,
  domain = rent_county_shifted$pct_rent_burdened,
  bins = breaks,
  right = FALSE
)

# Step 5: Draw the map
stress_map <- leaflet(options = leafletOptions(
  minZoom = 4, maxZoom = 4,
  zoomControl = FALSE, dragging = FALSE,
  scrollWheelZoom = FALSE, doubleClickZoom = FALSE
)) %>%
  addTiles(urlTemplate = "") %>%
  addRectangles(-180, -90, 180, 90, fillColor = "white", fillOpacity = 1, stroke = FALSE) %>%
  addPolygons(data = mask_polygon, fillColor = "white", color = "white", weight = 0, fillOpacity = 1) %>%
  addPolygons(
    data = rent_county_shifted,
    fillColor = ~pal(pct_rent_burdened),
    color = "white", weight = 0.3, fillOpacity = 0.9,
    label = ~paste0(NAME, ": ", round(pct_rent_burdened, 1), "%"),
    highlightOptions = highlightOptions(weight = 1, color = "black", bringToFront = TRUE)
  ) %>%
  addPolygons(
    data = state_geom,
    fillOpacity = 0,
    color = "black", weight = 1,
    layerId = ~link,
    highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
  ) %>%
  addLegend(
  position = "topright",
  pal = pal,
  values = rent_county_shifted$pct_rent_burdened,
  title = "% Rent Burdened",
  opacity = 1,
  labFormat = labelFormat(suffix = "%")
) %>%
  setView(lng = -98.5, lat = 39.8, zoom = 8)

# Step 6: Clickable state links
stress_map <- onRender(stress_map, "
  function(el, x) {
    var map = this;
    var hash = window.location.hash;
    map.eachLayer(function(layer) {
      if (layer.options && layer.options.layerId) {
        layer.on('click', function(e) {
          window.top.location.href = layer.options.layerId + hash;
        });
      }
    });
  }
")

# Step 7: Save map
saveWidget(
  widget = stress_map,
  file = '/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/stress.html',
  selfcontained = FALSE
)


# avg rent by state maps 

rent_geom_data <- get_acs(
  geography = "county",
  variables = c(rent = "B25064_001"),
  year = 2023,
  survey = "acs5",
  geometry = TRUE,
  cb = TRUE,
  cache_table = TRUE
) %>%
  select(GEOID, NAME, rent = estimate, geometry) %>%
  mutate(
    state_fips = str_sub(GEOID, 1, 2)
  )

walk(unique(rent_geom_data$state_fips), function(fips) {
  state_data <- rent_geom_data %>% filter(state_fips == fips)

  if (nrow(state_data) == 0 || all(is.na(state_data$geometry))) return(NULL)

  vals <- state_data$rent
vals <- vals[is.finite(vals) & vals > 0]

if (length(unique(vals)) < 2) return(NULL)

# Fix: Generate breaks starting from actual min value
breaks <- pretty(range(vals),6)
breaks <- unique(breaks)

# Ensure breaks cover max value
if (max(vals) > max(breaks)) {
  breaks <- c(breaks, max(vals))
}

# Finalize color bin palette
colors <- colorRampPalette(brewer.pal(9, "Purples"))(length(breaks) - 1)
pal <- colorBin(palette = colors, domain = vals, bins = breaks, right = TRUE)

# Legend labels


  leaflet_map <- leaflet(state_data, options = leafletOptions(minZoom = 5, maxZoom = 8)) %>%
    addProviderTiles("CartoDB.PositronNoLabels") %>%
    addPolygons(
      fillColor = ~pal(rent),
      fillOpacity = 0.9,
      color = "white",
      weight = 1,
      label = ~paste0(NAME, ": $", formatC(rent, format = "d", big.mark = ",")),
      highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
    ) %>%
    addLegend(
  position = "topright",
  pal = pal,
  values = vals,
  title = "Median Gross Rent",
  opacity = 1,
  labFormat = labelFormat(prefix = "$", big.mark = ",")
)

  saveWidget(
    widget = leaflet_map,
    file = paste0(
      "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/rent-maps/",
      fips, ".html"
    ),
    selfcontained = FALSE
  )
})


# 'stress' maps 
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/stress-maps/"

walk(unique(rent_geom_data$state_fips), function(fips) {
  state_data <- rent_map_data %>% filter(state_fips == fips)

  if (nrow(state_data) == 0 || all(is.na(state_data$geometry))) return(NULL)

  vals <- state_data$pct_rent_burdened
  vals <- vals[is.finite(vals) & vals > 0]

  if (length(unique(vals)) < 2) return(NULL)

  # Generate pretty breaks (rounded %)
  breaks <- pretty(vals)
  breaks <- unique(round(breaks, 1))

  colors <- colorRampPalette(brewer.pal(9, "YlOrRd"))(length(breaks) - 1)
  pal <- colorBin(palette = colors, domain = vals, bins = breaks)

  leaflet_map <- leaflet(state_data, options = leafletOptions(minZoom = 5, maxZoom = 8)) %>%
    addProviderTiles("CartoDB.PositronNoLabels") %>%
    addPolygons(
      fillColor = ~pal(pct_rent_burdened),
      fillOpacity = 0.9,
      color = "white",
      weight = 1,
      label = ~paste0(NAME, ": ", round(pct_rent_burdened, 1), "%"),
      highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
    ) %>%
    addLegend(
      position = "topright",
      colors = colors,
      labels = paste0(breaks[-length(breaks)], "%+"),
      title = "% Rent Burdened (30%+)",
      opacity = 1
    )

  saveWidget(
    widget = leaflet_map,
    file = file.path(output_dir, paste0(fips, ".html")),
    selfcontained = FALSE
  )
})
rent_stress_df <- rent_stress_df %>% mutate(state_fips = substr(GEOID, 1, 2))

# create rent state pages 
library(fs)
library(glue)
library(readr)
library(stringr)
library(dplyr)
library(knitr)
library(kableExtra)

output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/stress-pages/"

walk(unique(rent_stress_df$state_fips), function(fips_code) {

  html_content <- glue('
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Rent Stress, Median Rent & Stats – State {fips_code} (2023)</title>
  <style>
    body {{
      margin: 0;
      padding: 1.5rem;
      font-family: sans-serif;
      background-color: #f9f9f9;
    }}
    h1 {{
      font-size: 1.5rem;
      margin-bottom: 1.5rem;
    }}
    .row {{
      display: flex;
      gap: 2rem;
      align-items: flex-start;
    }}
    .col-large {{
      flex: 2;
    }}
    .col-small {{
      flex: 1;
    }}
    .map-title {{
      font-size: 1.1rem;
      font-weight: bold;
      margin-bottom: 0.5rem;
    }}
    .map-box {{
      border: 2px solid #ccc;
      padding: 0.5rem;
      background-color: white;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }}
    iframe {{
      width: 100%;
      height: 550px;
      border: none;
      margin-bottom: 1.5rem;
    }}
    .table-title {{
      font-size: 1.1rem;
      font-weight: bold;
      margin: 2rem 0 0.5rem 0;
    }}
    .description-box {{
      margin-top: 2rem;
      padding: 1rem;
      background-color: #eef0f4;
      border-left: 4px solid #4a142e;
      font-size: 0.95rem;
      line-height: 1.5;
    }}
  </style>
</head>
<body>

  <h1>Renter Housing Statistics – State {fips_code}</h1>

  <div class="row">
    <div class="col-large">
      <div class="map-title">% Rent Burdened (30%+) by County</div>
      <iframe src="../stress-maps/{fips_code}.html" title="Rent Burdened Map"></iframe>

      <div class="table-title">County-Level Housing Indicators</div>
      <iframe src="../facts-table-stress/{fips_code}.html" title="Rent Table"></iframe>
    </div>

    <div class="col-small">
      <div class="map-box">
        <div class="map-title">Median Gross Rent by County</div>
        <iframe src="../rent-maps/{fips_code}.html" title="Median Rent Map"></iframe>
      </div>

      <div class="description-box">
        <strong>What Do These Housing Indicators Show?</strong><br>
        All percentages in the table and map are calculated relative to the population of <strong>renter-occupied households</strong> in each county.
        <ul style="margin-top: 0.5rem;">
          <li><strong>% Renters</strong>: Percent of the county\'s population living in renter-occupied housing.</li>
          <li><strong>% Rent Burdened (30%+)</strong>: Share of renters spending 30% or more of their household income on rent.</li>
          <li><strong>Rental Vacancy Rate</strong>: The proportion of available rental units that are currently vacant. A lower rate means tighter rental markets and potentially more competition and pressure on renters.</li>
        </ul>
       
      </div>
    </div>
  </div>

</body>
</html>
')

  # Save HTML file
  write_file(html_content, path(output_dir, paste0(fips_code, ".html")))
})

```

# stress tables 
```{r}

output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/facts-table-stress/"
# Define variables
vars <- c(
  rent = "B25064_001",            # Median gross rent
  renters = "B25070_001",         # Total renters
  burden_30_34 = "B25070_006",
  burden_35_39 = "B25070_007",
  burden_40_49 = "B25070_008",
  burden_50_plus = "B25070_009",
  vacancy_rate = "DP04_0043PE",   # Rental vacancy rate (%)
  total_pop = "B01003_001"        # Total population
)

# Get ACS data (wide format)
rent_data <- get_acs(
  geography = "county",
  variables = vars,
  year = 2023,
  survey = "acs5",
  output = "wide",
  cache_table = TRUE
)

# Clean and calculate values
rent_clean <- rent_data %>%
  transmute(
    GEOID,
    NAME,
    median_rent = rentE,
    total_renters = rentersE,
    total_burdened = burden_30_34E + burden_35_39E + burden_40_49E + burden_50_plusE,
    pct_rent_burdened = 100 * total_burdened / total_renters,
    vacancy_rate = vacancy_rate,  # Already percent
    total_pop = total_popE,
    pct_renters = 100 * total_renters / total_pop,
    state_fips = str_sub(GEOID, 1, 2)
  )

# Loop through each state and generate tables
walk(unique(rent_clean$state_fips), function(fips) {
  state_data <- rent_clean %>%
    filter(state_fips == fips)

  if (nrow(state_data) == 0) return(NULL)

  table_data <- state_data %>%
    mutate(
      County = NAME,
      `Median Gross Rent ($)` = dollar(median_rent, accuracy = 1),
      `% Renters` = round(pct_renters, 1),
      `% Rent Burdened (30%+)` = round(pct_rent_burdened, 1),
      `Rental Vacancy Rate (%)` = round(vacancy_rate, 1)
    ) %>%
    select(
      County,
      `Median Gross Rent ($)`,
      `% Renters`,
      `% Rent Burdened (30%+)`,
      `Rental Vacancy Rate (%)`
    )

  dt_widget <- datatable(
    table_data,
    rownames = FALSE,
    options = list(
      pageLength = 25,
      autoWidth = TRUE,
      dom = 'tip',
      ordering = TRUE
    ),
    class = "stripe hover compact"
  )

  saveWidget(
    widget = dt_widget,
    file = file.path(output_dir, paste0(fips, ".html")),
    selfcontained = TRUE
  )
})
```

# stress pages

```{r}

folder_path <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/stress-pages"

html_files <- list.files(folder_path, pattern = "^\\d{2}\\.html$", full.names = TRUE)

for (file in html_files) {
  state_fips <- str_extract(basename(file), "^\\d{2}")

  map_src   <- glue("../stress-maps/{state_fips}.html")
  rent_src  <- glue("../rent-maps/{state_fips}.html")
  table_src <- glue("../facts-table-stress/{state_fips}.html")

  new_html <- glue('
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Rent Stress, Median Rent & Stats – State {state_fips} (2023)</title>
  <style>
    body {{
      margin: 0;
      padding: 2rem;
      font-family: system-ui, sans-serif;
      background-color: #f4f6f8;
      color: #222;
    }}

    h1 {{
      font-size: 2rem;
      font-weight: 700;
      margin-bottom: 1rem;
      margin-top: -1rem;
      color: #2a2a2a;
    }}

    .grid-container {{
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 2rem;
      align-items: start;
    }}

    .section-title {{
      font-size: 1.2rem;
      font-weight: 600;
      margin-bottom: 0.75rem;
      color: #333;
    }}

    .map-frame, .table-frame {{
      background-color: #fff;
      border: 1px solid #ddd;
      border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
      padding: 1rem;
      margin-bottom: 2rem;
    }}

    iframe {{
      width: 100%;
      height: 500px;
      border: none;
      border-radius: 6px;
    }}

    .description-box {{
      background-color: #f1f4fb;
      border-left: 5px solid #3e49a8;
      padding: 1rem 1.25rem;
      border-radius: 6px;
      font-size: 0.95rem;
      line-height: 1.6;
      margin-top: 2rem;
    }}

    .description-box strong {{
      display: block;
      margin-bottom: 0.5rem;
      font-size: 1rem;
    }}

    .description-box ul {{
      margin: 0.5rem 0 0 1rem;
      padding-left: 1rem;
    }}

    .description-box li {{
      margin-bottom: 0.5rem;
    }}

    @media (max-width: 900px) {{
      .grid-container {{
        grid-template-columns: 1fr;
      }}

      iframe {{
        height: 400px;
      }}
    }}
  </style>
</head>
<body>

  <h1>Renter Housing Statistics – {state_fips} (2023)</h1>

  <div class="grid-container">
    <!-- Left Column -->
    <div>
      <div class="map-frame">
        <div class="section-title">% Rent Burdened (30%+) by County</div>
        <iframe src="{map_src}" title="Rent Burdened Map"></iframe>
      </div>

      <div class="table-frame">
        <div class="section-title">County-Level Housing Indicators</div>
        <iframe src="{table_src}" title="Rent Table"></iframe>
      </div>
    </div>

    <!-- Right Column -->
    <div>
      <div class="map-frame">
        <div class="section-title">Median Gross Rent by County</div>
        <iframe src="{rent_src}" title="Median Rent Map"></iframe>
      </div>

      <div class="description-box">
        <strong>What Do These Housing Indicators Show?</strong>
        All values are based on renter-occupied households in each county.
        <ul>
          <li><strong>% Renters</strong>: Share of the population living in rented housing.</li>
          <li><strong>% Rent Burdened (30%+)</strong>: Renters spending 30%+ of income on rent.</li>
          <li><strong>Rental Vacancy Rate</strong>: Share of rental units that are currently vacant.</li>
          <li><strong>Median Gross Rent</strong>: Monthly rent including utilities (if paid by tenant).</li>
        </ul>
      </div>
    </div>
  </div>

</body>
</html>
')

  writeLines(new_html, file)
  message("✅ Updated:", basename(file))
}

```


# county stats tables 
```{r}


year <- 2023
states <- unique(fips_codes$state)[1:51]  # Lower 50 + DC

# 1. Median Earnings
earnings_all <- map_dfr(states, ~{
  get_acs(
    geography = "county",
    variables = "B20004_001",  # ✅ Median earnings for 25+
    state = .x,
    year = year,
    survey = "acs5"
  )
})

# 2. Education (% Bachelor's+)
edu_vars <- c(
  total = "B15003_001",
  bachelors = "B15003_022",
  masters = "B15003_023",
  prof = "B15003_024",
  doctorate = "B15003_025"
)

education_all <- map_dfr(states, ~{
  get_acs(
    geography = "county",
    variables = edu_vars,
    state = .x,
    year = year,
    survey = "acs5"
  )
})

# 3. Employment (% Full-Time)
emp_vars <- c(
  total = "B23022_001",
  male_full = "B23022_005",
  fem_full = "B23022_028"
)

employment_all <- map_dfr(states, ~{
  get_acs(
    geography = "county",
    variables = emp_vars,
    state = .x,
    year = year,
    survey = "acs5"
  )
})

employment_clean <- employment_all %>%
  select(-moe) %>%
  pivot_wider(names_from = variable, values_from = estimate) %>%
  transmute(
    GEOID,
    NAME,
    pct_full_time = 100 * (male_full + fem_full) / total
  )

state_fips_codes <- fips_codes %>%
  distinct(state, state_code) %>%
  filter(state %in% states) %>%
  arrange(state) %>%
  pull(state_code)

output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/facts-tables/"
dir.create(output_dir, showWarnings = FALSE)

walk2(states, state_fips_codes, function(state_abbr, state_fips) {
  message("Processing: ", state_abbr)

  earnings <- earnings_all %>%
    filter(str_sub(GEOID, 1, 2) == state_fips) %>%
    select(GEOID, NAME, median_earnings = estimate)

  education <- education_all %>%
    filter(str_sub(GEOID, 1, 2) == state_fips) %>%
    group_by(GEOID, NAME) %>%
    summarize(
      pct_bachelor_plus = 100 * sum(estimate[variable != "total"]) / estimate[variable == "total"],
      .groups = "drop"
    )

  employment <- employment_clean %>%
    filter(str_sub(GEOID, 1, 2) == state_fips)

  table_data <- earnings %>%
  left_join(education, by = c("GEOID", "NAME")) %>%
  left_join(employment, by = c("GEOID", "NAME")) %>%
  mutate(
    `Median Earnings ($)` = dollar(median_earnings, accuracy = 1),
    `% Bachelor's+` = round(pct_bachelor_plus, 1),
    `% Full-Time` = round(pct_full_time, 1),
    County = NAME
  ) %>%
  select(
    County,
    `Median Earnings ($)`,
    `% Bachelor's+`,
    `% Full-Time`
  )

  # Create sortable DT widget
  dt_widget <- datatable(
    table_data,
    rownames = FALSE,
    options = list(
      pageLength = 25,
      autoWidth = TRUE,
      dom = 'tip',
      ordering = TRUE
    ),
    class = "stripe hover compact"
  )

  # Render the DT widget as HTML and write to file
  saveWidget(
    dt_widget,
    file = file.path(output_dir, paste0(state_fips, ".html")),
    selfcontained = TRUE
  )
})

fips_to_state <- c(
  "01" = "Alabama", "02" = "Alaska", "04" = "Arizona", "05" = "Arkansas",
  "06" = "California", "08" = "Colorado", "09" = "Connecticut", "10" = "Delaware",
  "11" = "District of Columbia", "12" = "Florida", "13" = "Georgia", "15" = "Hawaii",
  "16" = "Idaho", "17" = "Illinois", "18" = "Indiana", "19" = "Iowa",
  "20" = "Kansas", "21" = "Kentucky", "22" = "Louisiana", "23" = "Maine",
  "24" = "Maryland", "25" = "Massachusetts", "26" = "Michigan", "27" = "Minnesota",
  "28" = "Mississippi", "29" = "Missouri", "30" = "Montana", "31" = "Nebraska",
  "32" = "Nevada", "33" = "New Hampshire", "34" = "New Jersey", "35" = "New Mexico",
  "36" = "New York", "37" = "North Carolina", "38" = "North Dakota", "39" = "Ohio",
  "40" = "Oklahoma", "41" = "Oregon", "42" = "Pennsylvania", "44" = "Rhode Island",
  "45" = "South Carolina", "46" = "South Dakota", "47" = "Tennessee", "48" = "Texas",
  "49" = "Utah", "50" = "Vermont", "51" = "Virginia", "53" = "Washington",
  "54" = "West Virginia", "55" = "Wisconsin", "56" = "Wyoming"
)

# insert 
input_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/earnings-pages"
output_dir <- input_dir  # overwrite in place

html_files <- dir_ls(input_dir, regexp = "\\d{2}\\.html$")

walk(html_files, function(file_path) {
  fips_code <- str_extract(path_file(file_path), "^\\d{2}")
  
  state <- fips_to_state[[fips_code]]
  html_content <- glue('
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>County Statistics by Earnings and Education</title>
  <style>
    body {{
      margin: 0;
      font-family: sans-serif;
      background-color: white;
    }}

    h1 {{
      text-align: center;
      font-size: 1.8rem;
      margin: 1rem 0;
    }}

    .container {{
      display: flex;
      width: 100%;
      height: 90vh;
      border-top: 1px solid #aaa;
      border-bottom: 1px solid #aaa;
    }}

    .map {{
      flex: 1;
      border-right: 2px solid #999;
    }}

    .map iframe {{
      width: 100%;
      height: 100%;
      border: none;
    }}

    .chart {{
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
    }}

    .chart iframe {{
      width: 90%;
      height: 90%;
      border: none;
    }}
  </style>
</head>
<body>
  <h1>Median Earnings by County - {state} </h1>
  <div class="container">
    <div class="map">
      <iframe src="../earnings-maps/{fips_code}.html"></iframe>
    </div>
    <div class="chart">
      <iframe src="../facts-tables/{fips_code}.html"></iframe>
    </div>
  </div>
</body>
</html>
  ')

  write_file(html_content, file_path)
  cat("✅ Updated:", file_path, "\n")
})





# county tables 
library(tidycensus)
library(tigris)
library(dplyr)
library(tidyr)
library(DT)
library(scales)
library(purrr)
library(sf)
library(readr)
library(htmlwidgets)
library(stringr)

options(tigris_use_cache = TRUE)
year <- 2023

# ----- Output Directory -----
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/sd-facts-county/"
dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)

# ----- Load Core ACS Data -----
# 1. Per Capita Income
percap_all <- get_acs(
  geography = "school district (unified)",
  variables = "B19301_001",
  year = year,
  survey = "acs5",
  geometry = TRUE
) %>%
  rename(percap = estimate) %>%
  select(GEOID, NAME, percap, geometry)

# 2. Educational Attainment
edu_vars <- c(
  total = "B15003_001",
  bachelors = "B15003_022",
  masters = "B15003_023",
  prof = "B15003_024",
  doctorate = "B15003_025"
)

education_all <- get_acs(
  geography = "school district (unified)",
  variables = edu_vars,
  year = year,
  survey = "acs5"
)

education_clean <- education_all %>%
  select(-moe) %>%
  pivot_wider(names_from = variable, values_from = estimate) %>%
  mutate(
    pct_bachelor_plus = 100 * (bachelors + masters + prof + doctorate) / total
  ) %>%
  select(GEOID, pct_bachelor_plus)

# 3. Employment
emp_vars <- c(
  total = "B23022_001",
  male_full = "B23022_005",
  fem_full = "B23022_028"
)

employment_all <- get_acs(
  geography = "school district (unified)",
  variables = emp_vars,
  year = year,
  survey = "acs5"
)

employment_clean <- employment_all %>%
  select(-moe) %>%
  pivot_wider(names_from = variable, values_from = estimate) %>%
  mutate(
    pct_full_time = 100 * (male_full + fem_full) / total
  ) %>%
  select(GEOID, pct_full_time)

# ----- Combine All School District Stats -----
district_stats <- percap_all %>%
  st_transform(4326) %>%
  left_join(education_clean, by = "GEOID") %>%
  left_join(employment_clean, by = "GEOID") %>%
  mutate(
    `Per Capita Income ($)` = dollar(percap, accuracy = 1),
    `% Bachelor's+` = round(pct_bachelor_plus, 1),
    `% Full-Time` = round(pct_full_time, 1),
    District = NAME
  ) %>%
  select(GEOID, District, `Per Capita Income ($)`, `% Bachelor's+`, `% Full-Time`, geometry)

# ----- Spatial Join: Assign Each District to a County -----
counties_sf <- counties(cb = TRUE, year = year) %>%
  st_transform(4326) %>%
  select(county_fips = GEOID, county_name = NAME)

district_with_county <- st_join(district_stats, counties_sf, join = st_intersects, left = FALSE) %>%
  st_drop_geometry()

# ----- Loop: One HTML Table Per County -----
county_list <- unique(district_with_county$county_fips)

walk(county_list, function(cfips) {
  df <- district_with_county %>%
    filter(county_fips == cfips) %>%
    select(District, `Per Capita Income ($)`, `% Bachelor's+`, `% Full-Time`)

  if (nrow(df) == 0) return(NULL)

  dt_widget <- datatable(
    df,
    rownames = FALSE,
    options = list(
      pageLength = 25,
      autoWidth = TRUE,
      ordering = TRUE,
      dom = 'tip'
    ),
    class = "stripe hover compact"
  )

  saveWidget(
    dt_widget,
    file = file.path(output_dir, paste0(cfips, ".html")),
    selfcontained = TRUE
  )

  cat("✅ County page saved:", cfips, "\n")
})




# county pages 


input_map_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/school-maps"
input_table_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/sd-facts-county"
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/count-pages"

# List county GEOID files
geoids <- dir_ls(input_map_dir, regexp = "\\.html$") %>% path_file() %>% path_ext_remove()

walk(geoids, function(geoid) {
  table_path <- file.path(input_table_dir, paste0(geoid, ".html"))
  map_src <- glue("../school-maps/{geoid}.html")

  if (!file_exists(table_path)) return(cat("⚠️ Missing table:", geoid, "\n"))

  # Extract <table> tag
  table_html <- read_file(table_path) %>%
    str_extract("(?s)<table.*?</table>")

  html_content <- glue('
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Per Capita Income and Education – County {geoid}</title>
  <style>
    body {{
      margin: 0;
      padding: 2rem;
      font-family: sans-serif;
      background-color: #f9f9f9;
    }}
    h1 {{
      font-size: 1.5rem;
      margin-bottom: 1.5rem;
    }}
    .container {{
      display: flex;
      gap: 2rem;
    }}
    .map {{
      flex: 2;
    }}
    .table-box {{
      flex: 1.2;
      background-color: white;
      padding: 1rem;
      border: 1px solid #ccc;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      overflow-x: auto;
    }}
    iframe {{
      width: 100%;
      height: 550px;
      border: none;
    }}
    table {{
      font-size: 0.95rem;
      border-collapse: collapse;
      width: 100%;
    }}
    th, td {{
      padding: 6px;
      border: 1px solid #ccc;
      text-align: left;
    }}
    th {{
      background-color: #f0f0f0;
    }}
  </style>
</head>
<body>

  <h1>County-Level Per Capita Income – GEOID {geoid} (2023)</h1>

  <div class="container">
    <div class="map">
      <iframe src="{map_src}" title="Per Capita Income Map – County {geoid}"></iframe>
    </div>
    <div class="table-box">
      <div><strong>Economic & Educational Stats</strong></div>
      <iframe src="../sd-facts-county/{geoid}.html"></iframe>
    </div>
  </div>

</body>
</html>
')

  write_file(html_content, path(output_dir, paste0(geoid, ".html")))
  cat("✅ Wrote:", geoid, "\n")
})


```


# income inequality widgets 
```{r}


# Step 1: Pull ACS data
income_quintiles <- get_acs(
  geography = "county",
  variables = c(
    total = "B19081_001",
    q1 = "B19081_002",
    q2 = "B19081_003",
    q3 = "B19081_004",
    q4 = "B19081_005",
    q5 = "B19081_006"
  ),
  year = 2023,
  survey = "acs5",
  geometry = FALSE
)

# Step 2: Process data into shares
share_df <- income_quintiles %>%
  select(GEOID, NAME, variable, estimate) %>%
  pivot_wider(names_from = variable, values_from = estimate) %>%
  mutate(
    qsum = q1 + q2 + q3 + q4 + q5,
    `Bottom 20%` = 100 * q1 / qsum,
    `Second 20%` = 100 * q2 / qsum,
    `Middle 20%` = 100 * q3 / qsum,
    `Fourth 20%` = 100 * q4 / qsum,
    `Top 20%` = 100 * q5 / qsum,
    state_fips = substr(GEOID, 1, 2)
  ) %>%
  select(GEOID, NAME, state_fips, `Bottom 20%`, `Second 20%`, `Middle 20%`, `Fourth 20%`, `Top 20%`)

# Step 3: Get FIPS to state name map
fips_to_state <- c(
  "01" = "Alabama", "02" = "Alaska", "04" = "Arizona", "05" = "Arkansas", "06" = "California",
  "08" = "Colorado", "09" = "Connecticut", "10" = "Delaware", "11" = "District of Columbia",
  "12" = "Florida", "13" = "Georgia", "15" = "Hawaii", "16" = "Idaho", "17" = "Illinois",
  "18" = "Indiana", "19" = "Iowa", "20" = "Kansas", "21" = "Kentucky", "22" = "Louisiana",
  "23" = "Maine", "24" = "Maryland", "25" = "Massachusetts", "26" = "Michigan", "27" = "Minnesota",
  "28" = "Mississippi", "29" = "Missouri", "30" = "Montana", "31" = "Nebraska", "32" = "Nevada",
  "33" = "New Hampshire", "34" = "New Jersey", "35" = "New Mexico", "36" = "New York",
  "37" = "North Carolina", "38" = "North Dakota", "39" = "Ohio", "40" = "Oklahoma",
  "41" = "Oregon", "42" = "Pennsylvania", "44" = "Rhode Island", "45" = "South Carolina",
  "46" = "South Dakota", "47" = "Tennessee", "48" = "Texas", "49" = "Utah", "50" = "Vermont",
  "51" = "Virginia", "53" = "Washington", "54" = "West Virginia", "55" = "Wisconsin", "56" = "Wyoming"
)
  
  # Step 4: Output directory
  output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/ineq-widgets"
  dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)
for (fips in names(fips_to_state)) {
  state_name <- fips_to_state[[fips]]
  df <- share_df %>% filter(state_fips == fips)

  if (nrow(df) == 0) next

  # Clean county names
  df <- df %>% mutate(NAME = str_replace(NAME, " County,.*", ""))

  # Compute statewide mean row
  statewide_row <- df %>%
    summarize(across(`Bottom 20%`:`Top 20%`, ~ mean(.x, na.rm = TRUE))) %>%
    as.numeric() %>%
    round(1)

  counties <- sort(unique(df$NAME))
  json_data <- list()
  json_data$Statewide <- setNames(statewide_row, c("Bottom 20%", "Second 20%", "Middle 20%", "Fourth 20%", "Top 20%"))

  # Add county JSON entries with "County, State" as keys
  option_tags <- c("<option value='Statewide'>Statewide</option>")
  for (cty in counties) {
    label_name <- paste0(cty, ", ", state_name)
    row <- df %>%
      filter(trimws(NAME) == trimws(cty)) %>%
      select(`Bottom 20%`, `Second 20%`, `Middle 20%`, `Fourth 20%`, `Top 20%`) %>%
      as.numeric()

    if (length(row) != 5 || any(is.na(row))) {
      json_data[[label_name]] <- json_data$Statewide
    } else {
      json_data[[label_name]] <- round(row, 1)
    }

    option_tags <- c(option_tags, glue("<option value='{label_name}'>{label_name}</option>"))
  }

  html <- tags$html(
    tags$head(
      tags$meta(charset = "UTF-8"),
      tags$title(paste("Income Distribution –", state_name)),
      tags$script(src = "https://cdn.jsdelivr.net/npm/chart.js"),
      tags$style(HTML("
        body {
          font-family: sans-serif;
          text-align: center;
          margin: 2rem;
        }
        select {
          font-size: 1rem;
          padding: 0.4rem;
          margin-bottom: 1rem;
        }
        canvas {
          width: 100%;
          max-width: 700px;
          height: 400px;
        }
      "))
    ),
    tags$body(
      tags$h2(paste("Income Share by Quintile –", state_name)),
      tags$label("Select County, State:"),
      HTML(glue('<select id="countySelect">{paste(option_tags, collapse = "\n")}</select>')),
      tags$canvas(id = "barChart", width = 700, height = 400),
      tags$script(HTML(glue("
        const incomeData = {toJSON(json_data, auto_unbox=TRUE)};
        const ctx = document.getElementById('barChart').getContext('2d');
        let chart;

        function renderChart(values) {{
          if (chart) chart.destroy();

          chart = new Chart(ctx, {{
            type: 'bar',
            data: {{
              labels: ['Bottom 20%', 'Second 20%', 'Middle 20%', 'Fourth 20%', 'Top 20%'],
              datasets: [{{
                label: 'Share (%)',
                data: values,
                backgroundColor: '#4576a7'
              }}]
            }},
            options: {{
              responsive: true,
              plugins: {{
                legend: {{ display: false }},
                tooltip: {{
                  callbacks: {{
                    label: ctx => ctx.parsed.y + '%'
                  }}
                }}
              }},
              scales: {{
                y: {{
                  beginAtZero: true,
                  max: 100,
                  title: {{
                    display: true,
                    text: 'Income Share (%)'
                  }}
                }},
                x: {{
                  title: {{
                    display: true,
                    text: 'Quintile'
                  }}
                }}
              }}
            }}
          }});
        }}

        document.getElementById('countySelect').addEventListener('change', function() {{
          renderChart(Object.values(incomeData[this.value]));
        }});

        renderChart(Object.values(incomeData['Statewide']));
      ")))
    )
  )

  htmltools::save_html(html, file = file.path(output_dir, paste0(fips, ".html")))
  cat("✅ Saved:", fips, "-", state_name, "\n")
}

```


# rewrite state name from fips code 
```{r}


# Folder containing the HTML files
html_folder <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/state-pages"

# FIPS to state name mapping
fips_to_state <- c(
  "01" = "Alabama", "02" = "Alaska", "04" = "Arizona", "05" = "Arkansas",
  "06" = "California", "08" = "Colorado", "09" = "Connecticut", "10" = "Delaware",
  "11" = "District of Columbia", "12" = "Florida", "13" = "Georgia", "15" = "Hawaii",
  "16" = "Idaho", "17" = "Illinois", "18" = "Indiana", "19" = "Iowa",
  "20" = "Kansas", "21" = "Kentucky", "22" = "Louisiana", "23" = "Maine",
  "24" = "Maryland", "25" = "Massachusetts", "26" = "Michigan", "27" = "Minnesota",
  "28" = "Mississippi", "29" = "Missouri", "30" = "Montana", "31" = "Nebraska",
  "32" = "Nevada", "33" = "New Hampshire", "34" = "New Jersey", "35" = "New Mexico",
  "36" = "New York", "37" = "North Carolina", "38" = "North Dakota", "39" = "Ohio",
  "40" = "Oklahoma", "41" = "Oregon", "42" = "Pennsylvania", "44" = "Rhode Island",
  "45" = "South Carolina", "46" = "South Dakota", "47" = "Tennessee", "48" = "Texas",
  "49" = "Utah", "50" = "Vermont", "51" = "Virginia", "53" = "Washington",
  "54" = "West Virginia", "55" = "Wisconsin", "56" = "Wyoming", "72" = "g"
)

# Get all .html files in folder
html_files <- dir_ls(html_folder, regexp = "\\.html$")

for (file_path in html_files) {
  fips <- str_extract(path_file(file_path), "^\\d{2}")  # e.g., "01" from "01.html"
  if (is.na(fips) || !(fips %in% names(fips_to_state))) next

  state <- fips_to_state[[fips]]

  # Read file
  lines <- readLines(file_path)

  # Replace all occurrences of "State XX" (e.g., "State 01") with state name
  lines <- str_replace_all(lines, paste0("State ", fips), state)

  # Also update iframe src="../seventy-county-maps/01.html" → same filename
  lines <- str_replace_all(lines, paste0("/", fips, ".html"), paste0("/", fips, ".html"))  # leave filename unchanged

  # Optionally, remove any lingering "State XX" patterns not already matched
  lines <- str_replace_all(lines, paste0("State ", fips), state)

  # Write back
  writeLines(lines, file_path)
}














page_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/ratio-pages"

# Description to inject
description_block <- '
  <div style="margin-top: 2rem; margin-right: -20rem; font-size: 0.95rem; line-height: 1.5;">
    <strong>About This Chart:</strong><br>
    This chart breaks down how total household income is distributed across income quintiles in the state.
    Each quintile represents 20% of households, ordered from lowest to highest income.
    The wider a bar, the more income that group collectively earns.
    <br><br>
    In a perfectly equal distribution, each group would hold about 20% of the income.
    However, most states show an unequal pattern, where the top 20% of households hold a disproportionate share.
  </div>
'

# Find all .html files in the directory
html_files <- dir_ls(page_dir, regexp = "\\.html$")

# Edit each file
library(glue)
library(fs)
library(purrr)
library(readr)


input_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/ratio-maps"
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/ratio-pages/"
image_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/ineq-widgets"  

fips_to_state <- c(
  "01" = "Alabama", "02" = "Alaska", "04" = "Arizona", "05" = "Arkansas",
  "06" = "California", "08" = "Colorado", "09" = "Connecticut", "10" = "Delaware",
  "11" = "District of Columbia", "12" = "Florida", "13" = "Georgia", "15" = "Hawaii",
  "16" = "Idaho", "17" = "Illinois", "18" = "Indiana", "19" = "Iowa",
  "20" = "Kansas", "21" = "Kentucky", "22" = "Louisiana", "23" = "Maine",
  "24" = "Maryland", "25" = "Massachusetts", "26" = "Michigan", "27" = "Minnesota",
  "28" = "Mississippi", "29" = "Missouri", "30" = "Montana", "31" = "Nebraska",
  "32" = "Nevada", "33" = "New Hampshire", "34" = "New Jersey", "35" = "New Mexico",
  "36" = "New York", "37" = "North Carolina", "38" = "North Dakota", "39" = "Ohio",
  "40" = "Oklahoma", "41" = "Oregon", "42" = "Pennsylvania", "44" = "Rhode Island",
  "45" = "South Carolina", "46" = "South Dakota", "47" = "Tennessee", "48" = "Texas",
  "49" = "Utah", "50" = "Vermont", "51" = "Virginia", "53" = "Washington",
  "54" = "West Virginia", "55" = "Wisconsin", "56" = "Wyoming"
)

html_files <- dir_ls(input_dir, regexp = "\\.html$")

walk(html_files, function(file_path) {
  fips_code <- path_file(file_path) %>% path_ext_remove()
  state_name <- fips_to_state[[fips_code]]

  html_content <- glue('
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Income Inequality Ratio – {state_name}</title>
  <style>
    body {{
      margin: 0;
      padding: 1.5rem;
      font-family: sans-serif;
      background-color: #f2f2f2;
    }}
    h1 {{
      font-size: 1.3rem;
      margin-bottom: 1rem;
    }}
    .container {{
      display: flex;
      gap: 2rem;
      align-items: flex-start;
    }}
    .map-column {{
      flex: 1;
    }}
    .sidebar {{
      flex: 1;
    }}
    iframe {{
      width: 100%;
      height: 600px;
      border: none;
    }}
    img {{
      max-width: 100%;
      height: auto;
      border: 1px solid #ccc;
      background: white;
      padding: 10px;
    }}
    .description {{
      margin-top: 1rem;
      font-size: 0.95rem;
      line-height: 1.5;
    }}
  </style>
</head>
<body>
  <h1>Income Inequality Ratio by County – {state_name}</h1>
  <div class="container">
    <div class="map-column">
      <iframe src="../ratio-maps/{fips_code}.html" title="Map of {state_name}"></iframe>
    </div>
    <div class="sidebar">
      <img src="../ineq-widgets/{fips_code}_ineq_bar.png" alt="Income Share Bar Chart for {state_name}">
      <div class="description">
        <strong>About This Chart:</strong><br>
        This chart breaks down how total household income is distributed across income quintiles in the state.
        Each quintile represents 20% of households, ordered from lowest to highest income.
        The wider a bar, the more income that group collectively earns.
        <br><br>
        In a perfectly equal distribution, each group would hold about 20% of the income.
        However, most states show an unequal pattern, where the top 20% of households hold a disproportionate share.
      </div>
    </div>
  </div>
</body>
</html>
')

  write_file(html_content, path(output_dir, paste0(fips_code, ".html")))
})
  
```


# more front page rank tables 
```{r}

library(tidycensus)
library(tidyverse)
library(sf)
library(DT)
library(htmlwidgets)
library(scales)
options(tigris_use_cache = TRUE)

# Define states
states <- state.abb

# Get 2018 and 2021 and 2023 population data
pop_2018 <- map_dfr(states, ~{
  Sys.sleep(0.5)
  get_acs(
    geography = "state",
    variables = "B01003_001",
    year = 2018,
    state = .x,
    geometry = TRUE
  )
})

pop_2021 <- map_dfr(states, ~{
  Sys.sleep(0.5)
  get_acs(
    geography = "state",
    variables = "B01003_001",
    year = 2021,
    state = .x,
    geometry = TRUE
  )
})

pop_2023 <- map_dfr(states, ~{
  Sys.sleep(0.5)
  get_acs(
    geography = "state",
    variables = "B01003_001",
    year = 2023,
    state = .x,
    geometry = TRUE
  )
})

# Clean 2023
pop_2023_clean <- pop_2023 %>%
  st_drop_geometry() %>%
  select(GEOID, pop_2023 = estimate)

# Clean and join for 2018–2023
pop_change_2018 <- pop_2018 %>%
  select(GEOID, NAME, pop_2018 = estimate, geometry) %>%
  left_join(pop_2023_clean, by = "GEOID") %>%
  mutate(
    state_fips = substr(GEOID, 1, 2),
    pct_change = 100 * (pop_2023 - pop_2018) / pop_2018
  )

# Clean and join for 2021–2023
pop_change_2021 <- pop_2021 %>%
  select(GEOID, NAME, pop_2021 = estimate, geometry) %>%
  left_join(pop_2023_clean, by = "GEOID") %>%
  mutate(
    state_fips = substr(GEOID, 1, 2),
    pct_change = 100 * (pop_2023 - pop_2021) / pop_2021
  )

# Aggregate to state level
get_state_growth <- function(df, base_col, year_range) {
  df %>%
    group_by(state_fips) %>%
    summarize(
      base_pop = sum(.data[[base_col]], na.rm = TRUE),
      pop_2023 = sum(pop_2023, na.rm = TRUE),
      geometry = st_union(geometry)
    ) %>%
    mutate(
      pct_change = round(100 * (pop_2023 - base_pop) / base_pop, 2),
      year_range = year_range
    )
}

pop_state_2018 <- get_state_growth(pop_change_2018, "pop_2018", "2018–2023")
pop_state_2021 <- get_state_growth(pop_change_2021, "pop_2021", "2021–2023")

# Get rankings
rank_pop_2023 <- pop_state_2023 <- pop_state_2023 <- pop_2023 %>%
  mutate(state_fips = substr(GEOID, 1, 2)) %>%
  group_by(state_fips) %>%
  summarize(pop_2023 = sum(estimate, na.rm = TRUE)) %>%
  arrange(desc(pop_2023)) %>%
  mutate(pop_rank = row_number()) %>%
  select(state_fips, pop_2023, pop_rank)

rank_growth_2018 <- pop_state_2018 %>%
  st_drop_geometry() %>%
  arrange(desc(pct_change)) %>%
  mutate(growth_rank = row_number()) %>%
  select(state_fips, pct_change, growth_rank)

rank_growth_2021 <- pop_state_2021 %>%
  st_drop_geometry() %>%
  arrange(desc(pct_change)) %>%
  mutate(growth_rank = row_number()) %>%
  select(state_fips, pct_change, growth_rank)

# State name mapping
state_names <- tidycensus::fips_codes %>%
  distinct(state_fips = state_code, state = state_name)

# Final tables
pop_table <- rank_pop_2023 %>%
  left_join(state_names, by = "state_fips") %>%
  arrange(pop_rank) %>%
  mutate(pop_2023 = comma(pop_2023)) %>%
  select(State = state, `2023 Population` = pop_2023)

growth_table_2018 <- rank_growth_2018 %>%
  left_join(state_names, by = "state_fips") %>%
  arrange(growth_rank) %>%
  mutate(pct_change = paste0(pct_change, "%")) %>%
  select(State = state, `Growth 2018–2023` = pct_change)

growth_table_2021 <- rank_growth_2021 %>%
  left_join(state_names, by = "state_fips") %>%
  arrange(growth_rank) %>%
  mutate(pct_change = paste0(pct_change, "%")) %>%
  select(State = state, `Growth 2021–2023` = pct_change)



saveWidget(
  datatable(growth_table_2018, options = list(pageLength = 50)),
  file = "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/growth-2018-2023.html",
  selfcontained = TRUE
)

saveWidget(
  datatable(growth_table_2021, options = list(pageLength = 50)),
  file = "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/growth-2021-2023.html",
  selfcontained = TRUE
)


```

# fix? 
```{r}

library(fs)
library(stringr)
library(readr)

# Folder with all the broken state pages
html_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/raceeth-2023/state-page-white"
state_lookup <- tibble::tibble(
  state_code = sprintf("%02d", c(
    1, 2, 4, 5, 6,
    8, 9, 10, 12, 13,
    15, 16, 17, 18, 19,
    20, 21, 22, 23, 24,
    25, 26, 27, 28, 29,
    30, 31, 32, 33, 34,
    35, 36, 37, 38, 39,
    40, 41, 42, 44, 45,
    46, 47, 48, 49, 50,
    51, 53, 54, 55, 56
  )),
  state_name = c(
    "Alabama", "Alaska", "Arizona", "Arkansas", "California",
    "Colorado", "Connecticut", "Delaware", "Florida", "Georgia",
    "Hawaii", "Idaho", "Illinois", "Indiana", "Iowa",
    "Kansas", "Kentucky", "Louisiana", "Maine", "Maryland",
    "Massachusetts", "Michigan", "Minnesota", "Mississippi", "Missouri",
    "Montana", "Nebraska", "Nevada", "New Hampshire", "New Jersey",
    "New Mexico", "New York", "North Carolina", "North Dakota", "Ohio",
    "Oklahoma", "Oregon", "Pennsylvania", "Rhode Island", "South Carolina",
    "South Dakota", "Tennessee", "Texas", "Utah", "Vermont",
    "Virginia", "Washington", "West Virginia", "Wisconsin", "Wyoming"
  )
)


# All HTML files like 06.html, 12.html, etc.
html_files <- dir_ls(html_dir, regexp = "\\d{2}\\.html$")

for (file in html_files) {
  filename <- path_file(file)
  state_fips <- str_extract(filename, "\\d{2}")
  state_name <- state_lookup$state_name[state_lookup$state_code == state_fips]

  lines <- read_lines(file)

  # Remove any incorrect <h2> or population headers
  cleaned <- lines[!str_detect(lines, "Population.*\\(\\%\\)")]

  # Insert properly spaced heading and a margin div
  new_heading <- paste0("<h2 style='margin-bottom: 1.5rem; margin-left: .5rem; margin-top: 1rem;'>White Population (%) in ", state_name, "</h2>")
  spacer <- "<div style='margin-top: 1rem'></div>"

  write_lines(c(new_heading, spacer, cleaned), file)
}



```




# ----------------------------------------------------------------------------MISC----------------------------------------------------------------------------------------------------------



# living alone 
```{r}
under65_vars <- c(
  married_family = "B09021_003",
  other_family = "B09021_004",
  nonfamily = "B09021_005",
  living_alone = "B09021_006",
  group_quarters = "B09021_007"
)

# Get all B09021 values
under65_all <- get_acs(
  geography = "county",
  variables = under65_vars,
  year = year,
  survey = "acs5",
  geometry = TRUE,
  cb = TRUE
) %>%
  select(GEOID, NAME, variable, estimate, geometry) %>%
  pivot_wider(names_from = variable, values_from = estimate) %>%
  mutate(
    total_under65 = married_family + other_family + nonfamily + living_alone + group_quarters,
    pct_under65_alone = living_alone / total_under65,
    state_fips = str_sub(GEOID, 1, 2)
  ) %>%
  filter(total_under65 > 0, !is.na(pct_under65_alone)) %>%
  st_transform(4326)

lonely_data <- under65_all

county_geom <- counties(cb = TRUE, year = 2023) %>%
  filter(!STATEFP %in% c("72", "78")) %>%
  select(GEOID, NAME, STATEFP, geometry) %>%
  rename(state_fips = STATEFP)  # ← this is critical

# State geometry with link
state_geom_under65 <- states(cb = TRUE, year = 2023) %>%
  filter(!STATEFP %in% c("72", "78")) %>%
  select(state_fips = STATEFP, geometry) %>%
  mutate(link = paste0("under65-pages/", state_fips, ".html"))

# Join under65_percent data by county
lonely_data <- county_geom %>%
  left_join(under65_percent, by = "GEOID")


# -------------------- SHIFT GEOMETRY FUNCTION --------------------
shift_geometry <- function(sf_obj) {
  alaska <- sf_obj %>% filter(state_fips == "02") %>% st_transform(2163)
  hawaii <- sf_obj %>% filter(state_fips == "15") %>% st_transform(2163)
  mainland <- sf_obj %>% filter(!state_fips %in% c("02", "15")) %>% st_transform(4326)
  alaska_geom <- st_geometry(alaska) * 0.3 + c(-380000, -3000000)
  hawaii_geom <- st_geometry(hawaii) * 1.2 + c(4500000, -900000)
  st_crs(alaska_geom) <- 2163; st_crs(hawaii_geom) <- 2163
  alaska <- st_set_geometry(alaska, alaska_geom) %>% st_transform(4326)
  hawaii <- st_set_geometry(hawaii, hawaii_geom) %>% st_transform(4326)
  bind_rows(mainland, alaska, hawaii) %>% st_as_sf()
}

# Shift geometries
state_geom_under65 <- shift_geometry(state_geom_under65)
lonely_shifted <- shift_geometry(lonely_data)

# -------------------- CREATE WHITE MASK --------------------
world_box <- st_as_sfc(st_bbox(c(xmin = -180, ymin = -90, xmax = 180, ymax = 90)), crs = 4326)
us_box <- st_as_sfc(st_bbox(c(xmin = -130, ymin = 15, xmax = -60, ymax = 55)), crs = 4326)
mask_polygon <- st_difference(st_make_valid(world_box), st_make_valid(us_box))
mask_polygon <- st_collection_extract(mask_polygon, "POLYGON")
st_crs(mask_polygon) <- 4326
mask_polygon <- st_transform(mask_polygon, 4326)

# -------------------- UNDER 65 MAP --------------------
vals_under65 <- lonely_shifted$`Living Alone`
breaks_u65 <- quantile(vals_under65, probs = seq(0, 1, length.out = 10), na.rm = TRUE)
breaks_u65 <- unique(round(breaks_u65, 4))
colors_u65 <- colorRampPalette(brewer.pal(9, "Blues"))(length(breaks_u65) - 1)
pal_u65 <- colorBin(colors_u65, domain = vals_under65, bins = breaks_u65)

under65_map <- leaflet(options = leafletOptions(
  minZoom = 4, maxZoom = 4,
  zoomControl = FALSE, dragging = FALSE,
  scrollWheelZoom = FALSE, doubleClickZoom = FALSE
)) %>%
  addTiles(urlTemplate = "") %>%
  addRectangles(lng1 = -180, lat1 = -90, lng2 = 180, lat2 = 90,
                fillColor = "white", fillOpacity = 1, stroke = FALSE) %>%
  addPolygons(data = mask_polygon, fillColor = "white", color = "white",
              weight = 0, fillOpacity = 1) %>%
  addPolygons(
    data = lonely_shifted,
    fillColor = ~pal_u65(`Living Alone`),
    color = "white", weight = 0.3, fillOpacity = 0.9,
    label = ~paste0(NAME, ": ", round(`Living Alone`, 1), "%"),
    highlightOptions = highlightOptions(weight = 1, color = "black", bringToFront = TRUE)
  ) %>%
  addPolygons(
    data = state_geom_under65,
    fillOpacity = 0, color = "black", weight = 1,
    layerId = ~link,
    highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
  ) %>%
  addLegend(
    position = "topright", colors = colors_u65,
    labels = paste0(round(breaks_u65[-length(breaks_u65)]), "%"),
    title = "Under 65 Living Alone", opacity = 1
  ) %>%
  setView(lng = -98.5, lat = 39.8, zoom = 8)

under65_map <- htmlwidgets::onRender(under65_map, "
  function(el, x) {
    var map = this;
    var hash = window.location.hash;
    map.eachLayer(function(layer) {
      if (layer.options && layer.options.layerId) {
        layer.on('click', function(e) {
          window.top.location.href = layer.options.layerId + hash;
        });
      }
    });
  }
")

saveWidget(
  widget = under65_map,
  file = '/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/lonely-under65.html',
  selfcontained = FALSE
)




# 65 PLUS 

states <- unique(tidycensus::fips_codes$state)[1:51]
year <- 2023

# Define variables from B09020
vars_65plus <- c(
  total_65plus = "B09020_001",
  living_alone = "B09020_013",
  group_quarters = "B09020_021"
)

get_living_65plus <- function(state_abbr) {
  message("Processing ", state_abbr)
  data <- get_acs(
    geography = "county",
    state = state_abbr,
    variables = vars_65plus,
    year = year,
    survey = "acs5"
  ) %>%
    select(GEOID, NAME, variable, estimate) %>%
    pivot_wider(names_from = variable, values_from = estimate) %>%
    mutate(
      STATE = state_abbr,
      County = NAME,
      `Living Alone (%)` = round(100 * living_alone / total_65plus, 1),
      `Group Quarters (%)` = round(100 * group_quarters / total_65plus, 1)
    )
  return(data)
}

living_65plus <- map_dfr(states, get_living_65plus)

# View the first few rows
head(living_65plus)


# --- 2. Shift geometry ---
shift_geometry <- function(sf_obj) {
  alaska <- sf_obj %>% filter(state_fips == "02") %>% st_transform(2163)
  hawaii <- sf_obj %>% filter(state_fips == "15") %>% st_transform(2163)
  mainland <- sf_obj %>% filter(!state_fips %in% c("02", "15")) %>% st_transform(4326)
  alaska_geom <- st_geometry(alaska) * 0.3 + c(-380000, -3000000)
  hawaii_geom <- st_geometry(hawaii) * 1.2 + c(4500000, -900000)
  st_crs(alaska_geom) <- 2163; st_crs(hawaii_geom) <- 2163
  alaska <- st_set_geometry(alaska, alaska_geom) %>% st_transform(4326)
  hawaii <- st_set_geometry(hawaii, hawaii_geom) %>% st_transform(4326)
  bind_rows(mainland, alaska, hawaii) %>% st_as_sf()
}

lonely_shifted <- shift_geometry(lonely_65plus_data)

# --- 3. Prepare map polygons and mask ---
state_geom_over65 <- states(cb = TRUE, year = year) %>%
  filter(!STATEFP %in% c("72", "78")) %>%
  select(state_fips = STATEFP, geometry) %>%
  mutate(link = paste0("over65-pages/", state_fips, ".html")) %>%
  shift_geometry()

world_box <- st_as_sfc(st_bbox(c(xmin = -180, ymin = -90, xmax = 180, ymax = 90)), crs = 4326)
us_box <- st_as_sfc(st_bbox(c(xmin = -130, ymin = 15, xmax = -60, ymax = 55)), crs = 4326)

mask_polygon <- st_difference(st_make_valid(world_box), st_make_valid(us_box)) %>%
  st_collection_extract("POLYGON")

# ✅ Explicitly set the CRS again
st_crs(mask_polygon) <- 4326


# --- 4. Binning and color scale ---
vals_65plus <- lonely_shifted$pct_65plus_alone
breaks_65 <- quantile(vals_65plus, probs = seq(0, 1, length.out = 11), na.rm = TRUE)
breaks_65 <- unique(round(breaks_65, 4))
colors_65 <- colorRampPalette(brewer.pal(9, "Blues"))(length(breaks_65) - 1)
pal_65 <- colorBin(colors_65, domain = vals_65plus, bins = breaks_65)

# --- 5. Draw Map ---
over65_map <- leaflet(options = leafletOptions(
  minZoom = 4, maxZoom = 4,
  zoomControl = FALSE, dragging = FALSE, scrollWheelZoom = FALSE, doubleClickZoom = FALSE
)) %>%
  addTiles(urlTemplate = "") %>%
  addRectangles(lng1 = -180, lat1 = -90, lng2 = 180, lat2 = 90,
                fillColor = "white", fillOpacity = 1, stroke = FALSE) %>%
  addPolygons(data = mask_polygon, fillColor = "white", color = "white", weight = 0, fillOpacity = 1) %>%
  addPolygons(
    data = lonely_shifted,
    fillColor = ~pal_65(pct_65plus_alone),
    color = "white", weight = 0.3, fillOpacity = 0.9,
    label = ~paste0(NAME, ": ", round(pct_65plus_alone * 100, 1), "%"),
    highlightOptions = highlightOptions(weight = 1, color = "black", bringToFront = TRUE)
  ) %>%
  addPolygons(
    data = state_geom_over65,
    fillOpacity = 0, color = "black", weight = 1,
    layerId = ~link,
    highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
  ) %>%
  addLegend(
    position = "topright", colors = colors_65,
    labels = paste0(round(breaks_65[-length(breaks_65)] * 100), "%"),
    title = "65+ Living Alone", opacity = 1
  ) %>%
  setView(lng = -98.5, lat = 39.8, zoom = 8)

over65_map <- htmlwidgets::onRender(over65_map, "
  function(el, x) {
    var map = this;
    var hash = window.location.hash;
    map.eachLayer(function(layer) {
      if (layer.options && layer.options.layerId) {
        layer.on('click', function(e) {
          window.top.location.href = layer.options.layerId + hash;
        });
      }
    });
  }
")

saveWidget(
  widget = over65_map,
  file = '/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/lonely-65plus.html',
  selfcontained = FALSE
)






# --- 7. State Maps ---

library(tidycensus)
library(dplyr)
library(tidyr)
library(stringr)
library(sf)
library(leaflet)
library(RColorBrewer)
library(htmlwidgets)
library(DT)
library(purrr)

year <- 2023
options(tigris_use_cache = TRUE)
states <- unique(tidycensus::fips_codes$state)[1:51]

# Accurate B09021 codes for 65+ living arrangements
vars_65plus <- c(
  married_family = "B09021_009",
  other_family = "B09021_010",
  nonfamily = "B09021_011",
  living_alone = "B09021_012",
  group_quarters = "B09021_013"
)

get_living_65plus <- function(state_abbr) {
  message("Processing ", state_abbr)
  get_acs(
    geography = "county",
    state = state_abbr,
    variables = vars_65plus,
    year = year,
    survey = "acs5",
    geometry = TRUE,
    cb = TRUE
  ) %>%
    select(GEOID, NAME, variable, estimate, geometry) %>%
    pivot_wider(names_from = variable, values_from = estimate) %>%
    mutate(
      total_65plus = married_family + other_family + nonfamily + living_alone + group_quarters,
      pct_65plus_alone = living_alone / total_65plus,
      state_fips = str_sub(GEOID, 1, 2),
      County = NAME
    ) %>%
    filter(total_65plus > 0, !is.na(pct_65plus_alone)) %>%
    st_transform(4326)
}

# Run full dataset for all states
lonely_65plus_data <- map_dfr(states, get_living_65plus)
living_65plus <- living_65plus %>%
  mutate(state_fips = str_sub(GEOID, 1, 2))
library(sf)
geo_65plus <- get_acs(
  geography = "county",
  variables = "B09021_012",  # dummy variable just to get geometry
  year = 2023,
  survey = "acs5",
  geometry = TRUE,
  cb = TRUE
) %>%
  select(GEOID, geometry) %>%
  st_transform(4326)
# Assuming living_65plus is just a tibble right now
living_65plus <- left_join(living_65plus, geo_65plus, by = "GEOID") %>%
  st_as_sf()

# Loop through each state and create a leaflet map
walk(unique(living_65plus$state_fips), function(fips) {
  state_data <- living_65plus %>%
    filter(state_fips == fips)

  # Ensure it is an sf object with geometry
  if (!inherits(state_data, "sf")) {
    message("Skipping FIPS ", fips, ": Not an sf object")
    return(NULL)
  }

  vals <- state_data$`Living Alone (%)`
  vals <- vals[is.finite(vals) & vals > 0]
  if (length(unique(vals)) < 2) return(NULL)

  breaks <- pretty(vals)
  colors <- colorRampPalette(brewer.pal(9, "Blues"))(length(breaks) - 1)
  pal <- colorBin(palette = colors, domain = vals, bins = breaks)

  leaflet_map <- leaflet(state_data) %>%
    addProviderTiles("CartoDB.PositronNoLabels") %>%
    addPolygons(
      fillColor = ~pal(`Living Alone (%)`),
      fillOpacity = 0.9,
      color = "white",
      weight = 1,
      label = ~paste0(County, ": ", `Living Alone (%)`, "%"),
      highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
    ) %>%
    addLegend(
      position = "topright",
      colors = colors,
      labels = paste0(round(breaks[-length(breaks)], 1), "%"),
      title = "65+ Living Alone",
      opacity = 1
    )

  saveWidget(
    widget = leaflet_map,
    file = file.path(
      "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/over65-maps/",
      paste0(fips, ".html")
    ),
    selfcontained = FALSE
  )
})



county_geom <- counties(cb = TRUE, year = 2023) %>%
  filter(!STATEFP %in% c("72", "78")) %>%
  select(GEOID, NAME, STATEFP, geometry) %>%
  rename(state_fips = STATEFP)

# Join with under65_percent data
lonely_data <- county_geom %>%
  left_join(under65_percent, by = "GEOID")

# Save individual state maps
walk(unique(lonely_data$state_fips), function(fips) {
  state_data <- lonely_data %>%
    filter(state_fips == fips)

  vals <- state_data$`Living Alone`
  vals <- vals[is.finite(vals) & vals > 0]

  if (length(unique(vals)) < 2) return(NULL)

  # Create color scale
  breaks <- pretty(vals)
  colors <- colorRampPalette(brewer.pal(9, "Blues"))(length(breaks) - 1)
  pal <- colorBin(palette = colors, domain = vals, bins = breaks)

  # Create leaflet map
  leaflet_map <- leaflet(state_data, options = leafletOptions(minZoom = 5, maxZoom = 8)) %>%
    addProviderTiles("CartoDB.PositronNoLabels") %>%
    addPolygons(
      fillColor = ~pal(`Living Alone`),
      fillOpacity = 0.9,
      color = "white",
      weight = 1,
      label = ~paste0(NAME, ": ", round(`Living Alone`, 1), "%"),
      highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
    ) %>%
    addLegend(
      position = "topright",
      colors = colors,
      labels = paste0(round(breaks[-length(breaks)], 1), "%"),
      title = "Under 65 Living Alone",
      opacity = 1
    )

  # Save map widget
  saveWidget(
    widget = leaflet_map,
    file = paste0(
      "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/under65-maps/",
      fips, ".html"
    ),
    selfcontained = FALSE
  )
})


# STATE PAGES LONELINESS UNDER 65 

library(fs)
library(glue)
library(readr)
library(stringr)
library(fs)
library(glue)
library(readr)
library(stringr)

input_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/under65-maps"
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/under65-pages/"

# List HTML files
html_files <- dir_ls(input_dir, regexp = "\\.html$")

walk(html_files, function(file_path) {
  fips_code <- path_file(file_path) %>% path_ext_remove()

  html_content <- glue('
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Under 65 Living Alone Map – State {fips_code}</title>
  <style>
    body {{
      margin: 0;
      padding: 1.5rem;
      font-family: sans-serif;
      background-color: #f2f2f2;
    }}
    h1 {{
      font-size: 1.3rem;
      margin-bottom: 1rem;
    }}
    .container {{
      display: flex;
      gap: 2rem;
    }}
    .map-column {{
      flex: 1;
    }}
    .sidebar {{
      flex: 1;
    }}
    iframe {{
      width: 100%;
      height: 600px;
      border: none;
    }}
    a#back-link {{
      display: inline-block;
      margin-bottom: 1rem;
      font-size: 0.95rem;
      color: #003366;
      text-decoration: none;
      font-weight: bold;
    }}
  </style>
</head>
<body>
  
  <h1>Under 65 Living Alonr by County – State {fips_code}</h1>
  <div class="container">
    <div class="map-column">
      <iframe src="../under65-maps/{fips_code}.html" title="Map of State {fips_code}"></iframe>
    </div>
    <div class="sidebar">
      <!-- You can add text, links, charts, etc. here later -->
    </div>
  </div>
</body>
</html>
')

  write_file(html_content, path(output_dir, paste0(fips_code, ".html")))
})




# STATE PAGES LONELINESS OVER 65 

library(fs)
library(glue)
library(readr)
library(stringr)
library(fs)
library(glue)
library(readr)
library(stringr)

input_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/over65-maps"
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/over65-pages/"

# List HTML files
html_files <- dir_ls(input_dir, regexp = "\\.html$")

walk(html_files, function(file_path) {
  fips_code <- path_file(file_path) %>% path_ext_remove()

  html_content <- glue('
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>65+ Living Alone Map – State {fips_code}</title>
  <style>
    body {{
      margin: 0;
      padding: 1.5rem;
      font-family: sans-serif;
      background-color: #f2f2f2;
    }}
    h1 {{
      font-size: 1.3rem;
      margin-bottom: 1rem;
    }}
    .container {{
      display: flex;
      gap: 2rem;
    }}
    .map-column {{
      flex: 1;
    }}
    .sidebar {{
      flex: 1;
    }}
    iframe {{
      width: 100%;
      height: 600px;
      border: none;
    }}
    a#back-link {{
      display: inline-block;
      margin-bottom: 1rem;
      font-size: 0.95rem;
      color: #003366;
      text-decoration: none;
      font-weight: bold;
    }}
  </style>
</head>
<body>
  
  <h1>65+ Living Alone by County – State {fips_code}</h1>
  <div class="container">
    <div class="map-column">
      <iframe src="../over65-maps/{fips_code}.html" title="Map of State {fips_code}"></iframe>
    </div>
    <div class="sidebar">
      <!-- You can add text, links, charts, etc. here later -->
    </div>
  </div>
</body>
</html>
')

  write_file(html_content, path(output_dir, paste0(fips_code, ".html")))
})




library(tidycensus)

pop_data <- get_acs(
  geography = "county",
  variables = "B01003_001",  # total population
  year = 2023,
  survey = "acs5"
)


counties_under_500 <- pop_data %>% filter(estimate < 500)    # counties under 200


```

# living alone living arrangement charts 
```{r}
library(tidycensus)
library(dplyr)
library(tidyr)
library(purrr)
library(DT)
library(htmlwidgets)
library(fs)
library(stringr)
states <- unique(tidycensus::fips_codes$state)[1:51]
year <- 2023

# 1. Total under-65 population using B01001 (male 3–20, female 27–44)
under65_age_vars <- c(
  paste0("B01001_", sprintf("%03d", 3:20)),    # Males under 65
  paste0("B01001_", sprintf("%03d", 27:44))    # Females under 65
)

total_under65 <- map_dfr(states, function(state_abbr) {
  get_acs(
    geography = "county",
    state = state_abbr,
    variables = under65_age_vars,
    year = year,
    survey = "acs5"
  ) %>%
    group_by(GEOID) %>%
    summarize(total_under65 = sum(estimate, na.rm = TRUE), .groups = "drop")
})

# 2. Living arrangement breakdown from B09021
under65_vars <- c(
  married_family = "B09021_003",
  other_family = "B09021_004",
  nonfamily = "B09021_005",
  living_alone = "B09021_006",
  group_quarters = "B09021_007"
)

get_under65_living_data <- function(state_abbr) {
  message("Processing ", state_abbr)
  get_acs(
    geography = "county",
    state = state_abbr,
    variables = under65_vars,
    year = year,
    survey = "acs5"
  ) %>%
    select(GEOID, NAME, variable, estimate) %>%
    pivot_wider(names_from = variable, values_from = estimate) %>%
    mutate(STATE = state_abbr, County = NAME)
}

all_under65_living <- map_dfr(states, get_under65_living_data)

# 3. Merge in total under-65 pop
all_under65_living <- left_join(all_under65_living, total_under65, by = "GEOID") %>%
  filter(!is.na(total_under65) & total_under65 > 0)

# 4. Calculate accurate, exclusive categories
under65_percent <- all_under65_living %>%
  mutate(
    nonfamily_shared = pmax(nonfamily - living_alone, 0),
total_reported = married_family + other_family + nonfamily_shared + living_alone + group_quarters,
`Married-Couple`        = round(100 * married_family / total_reported, 1),
`Other Family`          = round(100 * other_family / total_reported, 1),
`Nonfamily Household`   = round(100 * nonfamily_shared / total_reported, 1),
`Living Alone`          = round(100 * living_alone / total_reported, 1),
`Group Quarters`        = round(100 * group_quarters / total_reported, 1)

  ) %>%
  select(
    STATE, GEOID, County,
    `Married-Couple`, `Other Family`, `Nonfamily Household`, `Living Alone`, `Group Quarters`
  )

# 5. Save state-level widget tables
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/living-under65-tables"
dir_create(output_dir)

state_fips_list <- unique(substr(under65_percent$GEOID, 1, 2))

walk(state_fips_list, function(fips_code) {
  state_table <- under65_percent %>%
    filter(substr(GEOID, 1, 2) == fips_code) %>%
    select(County, `Married-Couple`, `Other Family`, `Nonfamily Household`, `Living Alone`, `Group Quarters`) %>%
    mutate(across(where(is.numeric), ~ paste0(.x, "%")))

  if (nrow(state_table) == 0) return()

  widget <- datatable(
    state_table,
    rownames = FALSE,
    options = list(
      pageLength = 25,
      autoWidth = TRUE,
      dom = 'tip',
      columnDefs = list(list(className = 'dt-center', targets = 1:5))
    )
  )

  saveWidget(
    widget,
    file = file.path(output_dir, paste0(fips_code, ".html")),
    selfcontained = TRUE
  )
})


# write to state pages 

library(fs)
library(stringr)
library(glue)
library(readr)

input_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/under65-maps"
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/under65-pages"
widget_dir <- "../living-under65-tables"

dir_create(output_dir)

# List state HTML files by FIPS
html_files <- dir_ls(input_dir, regexp = "\\.html$")

walk(html_files, function(file_path) {
  fips_code <- path_file(file_path) %>% path_ext_remove()

  html_content <- glue('
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Living Alone Under 65 – State {fips_code}</title>
  <style>
    body {{
      margin: 0;
      padding: 1.5rem;
      font-family: sans-serif;
      background-color: #f2f2f2;
    }}
    h1 {{
      font-size: 1.3rem;
      margin-bottom: 1rem;
    }}
    .container {{
      display: flex;
      gap: 2rem;
    }}
    .map-column {{
      flex: 1;
    }}
    .sidebar {{
      flex: 1;
    }}
    iframe {{
      width: 100%;
      height: 600px;
      border: none;
    }}
    a#back-link {{
      display: inline-block;
      margin-bottom: 1rem;
      font-size: 0.95rem;
      color: #003366;
      text-decoration: none;
      font-weight: bold;
    }}
  </style>
</head>
<body>
  <h1>Living Alone (Under Age 65) by County – State {fips_code}</h1>
  <div class="container">
    <div class="map-column">
      <iframe src="../under65-maps/{fips_code}.html" title="Map of State {fips_code}"></iframe>
    </div>
    <div class="sidebar">
      <h2 style="font-size: 1rem; color: #3e49a8; margin-top: 0;">Living Arrangements of People Under 65</h2>
      <iframe src="{widget_dir}/{fips_code}.html" title="Living Arrangements Table by County (Under 65)" width="100%" height="600px" style="border:none;"></iframe>
    </div>
  </div>
</body>
</html>
')

  write_file(html_content, path(output_dir, paste0(fips_code, ".html")))
})




# 65+ state tables 
library(tidycensus)
library(dplyr)
library(tidyr)
library(purrr)
library(stringr)

year <- 2023
states <- unique(fips_codes$state)[1:51]  # 50 states + DC

# Define correct variables from B09021
year <- 2023
states <- unique(fips_codes$state)[1:51]


over65_age_vars <- c(
  paste0("B01001_", sprintf("%03d", 21:25)),   # Males 65+
  paste0("B01001_", sprintf("%03d", 45:49))    # Females 65+
)

total_over65 <- map_dfr(states, function(state_abbr) {
  get_acs(
    geography = "county",
    state = state_abbr,
    variables = over65_age_vars,
    year = year,
    survey = "acs5"
  ) %>%
    group_by(GEOID) %>%
    summarize(total_over65 = sum(estimate, na.rm = TRUE), .groups = "drop")
})

# 2. Living arrangement breakdown for 65+ from B09021
vars <- c(
  total         = "B09021_001",
  married       = "B09021_009",
  living_alone  = "B09021_012"
)

get_living_65plus_simple <- function(state_abbr) {
  message("Processing ", state_abbr)

  get_acs(
    geography = "county",
    state = state_abbr,
    variables = vars,
    year = year,
    survey = "acs5"
  ) %>%
    select(GEOID, NAME, variable, estimate) %>%
    pivot_wider(names_from = variable, values_from = estimate) %>%
    mutate(
      STATE = state_abbr,
      County = NAME,
      other = pmax(`B09021_001` - `B09021_009` - `B09021_012`, 0),
      `Married-Couple (%)` = round(100 * `B09021_009` / `B09021_001`, 1),
      `Living Alone (%)`   = round(100 * `B09021_012` / `B09021_001`, 1),
      `Other (%)`          = round(100 * other / `B09021_001`, 1)
    ) %>%
    select(STATE, GEOID, County, `Married-Couple (%)`, `Living Alone (%)`, `Other (%)`) %>%
    filter(`B09021_001` > 0)
}

# Apply to all states
living_65plus_3cat <- map_dfr(states, get_living_65plus_simple)




# --- Save per-state tables ---
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/living-over65-tables"
dir_create(output_dir)

walk(unique(living_65plus$state_fips), function(fips_code) {
  state_table <- living_65plus %>%
    filter(state_fips == fips_code) %>%
    select(
      County,
      `Married-Couple (%)`,
      `Other Family (%)`,
      `Nonfamily Household (%)`,
      `Living Alone (%)`,
      `Group Quarters (%)`
    ) %>%
    mutate(across(where(is.numeric), ~ paste0(.x, "%")))

  if (nrow(state_table) == 0) return()

  widget <- datatable(
    state_table,
    rownames = FALSE,
    options = list(
      pageLength = 25,
      autoWidth = TRUE,
      dom = 'tip',
      columnDefs = list(list(className = 'dt-center', targets = 1:5))
    )
  )

  saveWidget(
    widget,
    file = file.path(output_dir, paste0(fips_code, ".html")),
    selfcontained = TRUE
  )
})

# write to pages 


input_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/over65-maps"
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/over65-pages"
widget_dir <- "../living-over65-tables"

dir_create(output_dir)

# List state HTML files by FIPS
html_files <- dir_ls(input_dir, regexp = "\\.html$")

walk(html_files, function(file_path) {
  fips_code <- path_file(file_path) %>% path_ext_remove()

  html_content <- glue('
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Living Alone 65+ – State {fips_code}</title>
  <style>
    body {{
      margin: 0;
      padding: 1.5rem;
      font-family: sans-serif;
      background-color: #f2f2f2;
    }}
    h1 {{
      font-size: 1.3rem;
      margin-bottom: 1rem;
    }}
    .container {{
      display: flex;
      gap: 2rem;
    }}
    .map-column {{
      flex: 1;
    }}
    .sidebar {{
      flex: 1;
    }}
    iframe {{
      width: 100%;
      height: 600px;
      border: none;
    }}
    a#back-link {{
      display: inline-block;
      margin-bottom: 1rem;
      font-size: 0.95rem;
      color: #003366;
      text-decoration: none;
      font-weight: bold;
    }}
  </style>
</head>
<body>
  <h1>Living Alone (Over Age 65) by County – State {fips_code}</h1>
  <div class="container">
    <div class="map-column">
      <iframe src="../over65-maps/{fips_code}.html" title="Map of State {fips_code}"></iframe>
    </div>
    <div class="sidebar">
      <h2 style="font-size: 1rem; color: #3e49a8; margin-top: 0;">Living Arrangements of People Under 65</h2>
      <iframe src="{widget_dir}/{fips_code}.html" title="Living Arrangements Table by County (Over 65)" width="100%" height="600px" style="border:none;"></iframe>
    </div>
  </div>
</body>
</html>
')

  write_file(html_content, path(output_dir, paste0(fips_code, ".html")))
})



year <- 2023
states <- unique(fips_codes$state)[1:51]

# Income variables for 65+ householders
income_vars <- paste0("B19037_", sprintf("%03d", 49:61))
bracket_labels <- c(
  "<$10k", "$10–14k", "$15–19k", "$20–24k", "$25–29k", "$30–34k",
  "$35–39k", "$40–44k", "$45–49k", "$50–59k", "$60–74k", "$75–99k", "$100k+"
)
bracket_df <- tibble(variable = income_vars, bracket = factor(bracket_labels, levels = bracket_labels))

# Get ACS data
income_65plus <- map_dfr(states, function(st) {
  get_acs(
    geography = "state",
    variables = income_vars,
    state = st,
    year = year,
    survey = "acs5"
  )
})

# Join labels and clean
income_clean <- income_65plus %>%
  left_join(bracket_df, by = "variable") %>%
  mutate(
    STATE = str_remove(NAME, " \\(.*\\)"),  # Remove "(State)"
    STATE_FILE = gsub(" ", "_", STATE)
  ) %>%
  select(STATE, STATE_FILE, bracket, estimate) %>%
  group_by(STATE, STATE_FILE) %>%
  mutate(pct = estimate / sum(estimate)) %>%
  ungroup()

# Output path
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/income-65plus-charts"
dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)

# Generate one chart per state
walk(unique(income_clean$STATE), function(state_name) {
  df <- income_clean %>% filter(STATE == state_name)
  state_file <- unique(df$STATE_FILE)

  p <- ggplot(df, aes(x = bracket, y = pct, fill = bracket)) +
  geom_col() +
  geom_text(
    aes(label = ifelse(pct < 0.005, "<1%", paste0(round(pct * 100), "%"))),
    vjust = -0.5,
    size = 3.5
  ) +
  scale_y_continuous(
  labels = percent_format(accuracy = 1),
  expand = expansion(mult = c(0, 0.15))  # 15% headroom at top
) + 
  scale_fill_brewer(palette = "Blues") +
  labs(
    title = paste("Income Distribution Among 65+ Households –", state_name),
    x = "Household Income Bracket",
    y = "Percent of 65+ Households"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "none"
  )

  ggsave(
    filename = file.path(output_dir, paste0(state_file, "_65plus_income.png")),
    plot = p, width = 10, height = 6
  )
})


fips_lookup <- tidycensus::fips_codes %>%
  group_by(state_code) %>%
  slice(1) %>%
  ungroup() %>%
  mutate(
    state_fips = state_code,
    state_name = gsub(" ", "_", state_name)
  ) %>%
  select(state_fips, state_name)

input_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/over65-maps"
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/over65-pages"
chart_dir <- "../income-65plus-charts"

dir_create(output_dir)

# FIPS to state name lookup
fips_lookup <- tidycensus::fips_codes %>%
  group_by(state_code) %>%
  slice(1) %>%
  ungroup() %>%
  mutate(
    state_fips = str_pad(state_code, 2, pad = "0"),
    state_file = gsub(" ", "_", state_name),
    state_label = state_name
  ) %>%
  select(state_fips, state_file, state_label)

# List state HTML files by FIPS
html_files <- dir_ls(input_dir, regexp = "\\.html$")

walk(html_files, function(file_path) {
  fips_code <- path_file(file_path) %>% path_ext_remove()

  # Lookup state name from FIPS
  state_row <- fips_lookup %>% filter(state_fips == fips_code)
  if (nrow(state_row) == 0) return(NULL)

  state_name <- state_row$state_name[[1]]
  state_label <- gsub("_", " ", state_row$state_label[[1]])

  html_content <- glue('
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Living Alone 65+ – {state_label}</title>
  ...
  <img src="{chart_dir}/{state_name}_65plus_income.png" alt="Income Distribution (Age 65+) – {state_label}" />
  ...
</html>
')

  write_file(html_content, path(output_dir, paste0(fips_code, ".html")))
})

```


# internet access

```{r}


v <- load_variables(2023, "acs5", cache = TRUE)

# Get internet access data
internet_data <- get_acs(
  geography = "county",
  variables = c(
    total = "B28002_001",
    no_internet = "B28002_002"
  ),
  year = 2023,
  survey = "acs5",
  geometry = TRUE
)

# Reshape and calculate % without internet
internet_clean <- internet_data %>%
  select(GEOID, NAME, variable, estimate, geometry) %>%
  pivot_wider(names_from = variable, values_from = estimate) %>%
  mutate(
    pct_no_internet = no_internet / total,
    state_fips = substr(GEOID, 1, 2)
  )

# -------------------- 2. SHIFT GEOMETRY --------------------
shift_geometry <- function(sf_obj) {
  alaska <- sf_obj %>% filter(state_fips == "02") %>% st_transform(2163)
  hawaii <- sf_obj %>% filter(state_fips == "15") %>% st_transform(2163)
  mainland <- sf_obj %>% filter(!state_fips %in% c("02", "15")) %>% st_transform(4326)
  alaska_geom <- st_geometry(alaska) * 0.3 + c(-380000, -3000000)
  hawaii_geom <- st_geometry(hawaii) * 1.2 + c(4500000, -900000)
  st_crs(alaska_geom) <- 2163; st_crs(hawaii_geom) <- 2163
  alaska <- st_set_geometry(alaska, alaska_geom) %>% st_transform(4326)
  hawaii <- st_set_geometry(hawaii, hawaii_geom) %>% st_transform(4326)
  bind_rows(mainland, alaska, hawaii) %>% st_as_sf()
}

internet_shifted <- shift_geometry(internet_clean)

# -------------------- 3. STATE GEOMETRY --------------------
state_geom_internet <- states(cb = TRUE, year = 2023) %>%
  filter(!STATEFP %in% c("72", "78")) %>%
  select(state_fips = STATEFP, geometry) %>%
  mutate(link = paste0("internet-pages/", state_fips, ".html"))

state_geom_internet <- shift_geometry(state_geom_internet)

# -------------------- 4. WHITE MASK --------------------
world_box <- st_as_sfc(st_bbox(c(xmin = -180, ymin = -90, xmax = 180, ymax = 90)), crs = 4326)
us_box <- st_as_sfc(st_bbox(c(xmin = -130, ymin = 15, xmax = -60, ymax = 55)), crs = 4326)
mask_polygon <- st_difference(st_make_valid(world_box), st_make_valid(us_box)) %>%
  st_collection_extract("POLYGON") %>%
  st_set_crs(4326)

# -------------------- 5. MAP SETUP --------------------
vals <- internet_shifted$pct_no_internet
max_val <- max(vals, na.rm = TRUE)

# Create 10 equal-width bins between 0 and max
breaks <- seq(0, ceiling(max_val * 100) / 100, length.out = 11)  # 10 breaks = 11 endpoints

colors <- colorRampPalette(brewer.pal(9, "OrRd"))(length(breaks) - 1)

pal <- colorBin(colors, domain = vals, bins = breaks)

internet_map <- leaflet(options = leafletOptions(
  minZoom = 4, maxZoom = 4,
  zoomControl = FALSE, dragging = FALSE,
  scrollWheelZoom = FALSE, doubleClickZoom = FALSE
)) %>%
  addTiles(urlTemplate = "") %>%
  addRectangles(lng1 = -180, lat1 = -90, lng2 = 180, lat2 = 90,
                fillColor = "white", fillOpacity = 1, stroke = FALSE) %>%
  addPolygons(data = mask_polygon, fillColor = "white", color = "white", weight = 0, fillOpacity = 1) %>%
  addPolygons(
    data = internet_shifted,
    fillColor = ~pal(pct_no_internet),
    color = "white", weight = 0.3, fillOpacity = 0.9,
    label = ~paste0(NAME, ": ", round(pct_no_internet * 100, 1), "%"),
    highlightOptions = highlightOptions(weight = 1, color = "black", bringToFront = TRUE)
  ) %>%
  addPolygons(
    data = state_geom_internet,
    fillOpacity = 0, color = "black", weight = 1,
    layerId = ~link,
    highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
  ) %>%
  addLegend(
    position = "topright", colors = colors,

labels = paste0(round(breaks[-length(breaks)] * 100), "%"),   
title = "Households Without Internet Access (2023)", opacity = 1
  ) %>%
  setView(lng = -98.5, lat = 39.8, zoom = 8)

# -------------------- 6. JS CLICK HANDLER --------------------
internet_map <- onRender(internet_map, "
  function(el, x) {
    var map = this;
    var hash = window.location.hash;
    map.eachLayer(function(layer) {
      if (layer.options && layer.options.layerId) {
        layer.on('click', function(e) {
          window.top.location.href = layer.options.layerId + hash;
        });
      }
    });
  }
")

# -------------------- 7. SAVE --------------------
saveWidget(
  widget = internet_map,
  file = "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/internet-map.html",
  selfcontained = FALSE
)




walk(unique(internet_clean$state_fips), function(fips) {
  state_data <- internet_clean %>%
    filter(state_fips == fips)

  vals <- state_data$pct_no_internet
  vals <- vals[is.finite(vals) & vals > 0]

  if (length(unique(vals)) < 2) return(NULL)

  breaks <- pretty(vals) 
  colors <- colorRampPalette(brewer.pal(9, "YlOrRd"))(length(breaks) - 1)
  pal <- colorBin(palette = colors, domain = vals, bins = breaks)

  leaflet_map <- leaflet(state_data, options = leafletOptions(minZoom = 5, maxZoom = 8)) %>%
    addProviderTiles("CartoDB.PositronNoLabels") %>%
    addPolygons(
      fillColor = ~pal(pct_no_internet),
      fillOpacity = 0.9,
      color = "white",
      weight = 1,
      label = ~paste0(NAME, ": ", round(pct_no_internet * 100, 1), "%"),
      highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
    ) %>%
    addLegend(
      position = "topright",
      colors = colors,
      labels = paste0(round(breaks[-length(breaks)] * 100, 1), "%"),
      title = "Households Without Internet Access (2023)",
      opacity = 1
    )

  saveWidget(
    widget = leaflet_map,
    file = paste0(
      "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/internet-maps/",
      fips, ".html"
    ),
    selfcontained = FALSE
  )
})




# STATE PAGES INTERNET

library(fs)
library(glue)
library(readr)
library(stringr)
library(fs)
library(glue)
library(readr)
library(stringr)

input_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/internet-maps"
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/internet-pages/"

# List HTML files
html_files <- dir_ls(input_dir, regexp = "\\.html$")

walk(html_files, function(file_path) {
  fips_code <- path_file(file_path) %>% path_ext_remove()

  html_content <- glue('
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Households Without Internet Access Map – State {fips_code}</title>
  <style>
    body {{
      margin: 0;
      padding: 1.5rem;
      font-family: sans-serif;
      background-color: #f2f2f2;
    }}
    h1 {{
      font-size: 1.3rem;
      margin-bottom: 1rem;
    }}
    .container {{
      display: flex;
      gap: 2rem;
    }}
    .map-column {{
      flex: 1;
    }}
    .sidebar {{
      flex: 1;
    }}
    iframe {{
      width: 100%;
      height: 600px;
      border: none;
    }}
    a#back-link {{
      display: inline-block;
      margin-bottom: 1rem;
      font-size: 0.95rem;
      color: #003366;
      text-decoration: none;
      font-weight: bold;
    }}
  </style>
</head>
<body>
  
  <h1>Households Without Internet by County – State {fips_code}</h1>
  <div class="container">
    <div class="map-column">
      <iframe src="../internet-maps/{fips_code}.html" title="Map of State {fips_code}"></iframe>
    </div>
    <div class="sidebar">
      <!-- You can add text, links, charts, etc. here later -->
    </div>
  </div>
</body>
</html>
')

  write_file(html_content, path(output_dir, paste0(fips_code, ".html")))
})





```

# internet acces CHARTS
```{r}

output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/internet-charts"

acs_years <- c(2013, 2014, 2015, 2016, 2017, 2018, 2019, 2021, 2022, 2023)

internet_data <- purrr::map_dfr(acs_years, function(y) {
  get_acs(
    geography = "county",
    variables = c(total = "B28002_001", with_internet = "B28002_002"),
    year = y,
    survey = "acs1",
    cache_table = TRUE
  ) %>%
    select(GEOID, NAME, variable, estimate) %>%
    pivot_wider(names_from = variable, values_from = estimate) %>%
    mutate(
      year = y,
      percent_with_internet = round(100 * with_internet / total, 1)
    )
}) %>%
  mutate(
    state = str_extract(NAME, ",\\s*([A-Z]{2})$") %>% str_remove(",\\s*"),
    state_fips = str_sub(GEOID, 1, 2)
  )
# ---------------------- WIDGET GENERATION ----------------------
unique_states <- unique(internet_data$state_fips)

for (st in unique_states) {
  state_data <- internet_data %>% filter(state_fips == st)
  counties <- sort(unique(state_data$NAME))

  # STATEWIDE AVERAGE
  statewide <- state_data %>%
    group_by(year) %>%
    summarise(total = sum(total), with_internet = sum(with_internet), .groups = "drop") %>%
    mutate(percent_with_internet = round(100 * with_internet / total, 1))

  json_data <- list()
json_data$Statewide <- as.list(setNames(
  round(statewide$percent_with_internet, 1),
  statewide$year
))
  for (cty in counties) {
    sub <- state_data %>% filter(NAME == cty)
    if (nrow(sub) == 0) next
    json_data[[cty]] <- as.list(setNames(
  round(sub$percent_with_internet, 1),
  sub$year
))
  }

  state_name <- state_data$NAME[1] %>% str_extract("[^,]+$")

  html <- tags$html(
    tags$head(
      tags$meta(charset = "UTF-8"),
      tags$title(paste("Internet Access Over Time –", state_name)),
      tags$script(src = "https://cdn.jsdelivr.net/npm/chart.js"),
      tags$style(HTML("body { font-family: sans-serif; margin: 1rem 2rem; text-align: center; }
                      h2 { margin-bottom: 0.25rem; font-size: 1.6rem; }
                      select { padding: 0.4rem; font-size: 1rem; margin: 1rem 0; border-radius: 5px; border: 1px solid #999; }
                      canvas { width: 100%; max-width: 850px; height: 450px; margin-top: 1rem; }"))
    ),
    tags$body(
      tags$h2(paste("Internet Access in", state_name, "(2013–2023)")),
      tags$label("Select County: "),
      HTML(glue('<select id="countySelect">{paste0("<option value=\'", c("Statewide", counties), "\'>", c("Statewide", counties), "</option>", collapse = "\n")}</select>')),
      tags$canvas(id = "lineChart", width = 850, height = 450),
      tags$script(HTML(glue("const internetData = {toJSON(json_data, auto_unbox=TRUE, digits = 3)};
const ctx = document.getElementById('lineChart').getContext('2d');
let chart;

function renderChart(data) {{
  const labels = Object.keys(data);
  const values = Object.values(data);

  if (chart) chart.destroy();
  chart = new Chart(ctx, {{
    type: 'line',
    data: {{
      labels: labels,
      datasets: [{{
        label: '% With Internet',
        data: values,
        fill: false,
        borderColor: 'teal',
        backgroundColor: 'teal',
        tension: 0.3,
        pointRadius: 4
      }}]
    }},
    options: {{
      responsive: true,
      scales: {{
        y: {{
          beginAtZero: true,
          max: 100,
          title: {{ display: true, text: '% With Internet' }}
        }},
        x: {{
          title: {{ display: true, text: 'Year' }}
        }}
      }},
      plugins: {{
        tooltip: {{
          callbacks: {{
            label: function(ctx) {{
              return ctx.parsed.y.toFixed(1) + '%';
            }}
          }}
        }}
      }}
    }}
  }});
}}

document.getElementById('countySelect').addEventListener('change', function() {{
  renderChart(internetData[this.value]);
}});
renderChart(internetData['Statewide']);"))
    ))
  )

  save_html(html, file = file.path(output_dir, paste0(st, ".html")))
  cat("✅ Saved widget for", state_name, "\n")
}




input_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/internet-maps"
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/internet-pages/"
chart_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/internet-charts"  # relative to output HTML

# FIPS to state name lookup

# List HTML map files
html_files <- dir_ls(input_dir, regexp = "\\.html$")

walk(html_files, function(file_path) {
  fips_code <- path_file(file_path) %>% path_ext_remove()



  chart_filename <- glue("{fips_code}.html")

  html_content <- glue('
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Households Without Internet Access Map – {state_name}</title>
  <style>
    body {{
      margin: 0;
      padding: 1.5rem;
      font-family: sans-serif;
      background-color: #f2f2f2;
    }}
    h1 {{
      font-size: 1.3rem;
      margin-bottom: 1rem;
    }}
    .container {{
      display: flex;
      gap: 2rem;
    }}
    .map-column {{
      flex: 1;
    }}
    .sidebar {{
      flex: 1;
    }}
    iframe {{
      width: 100%;
      height: 600px;
      border: none;
    }}
    img {{
      width: 100%;
      max-width: 100%;
      height: auto;
      margin-bottom: 1rem;
    }}
    .caption {{
      font-size: 0.9rem;
      line-height: 1.4;
      color: #444;
    }}
    a#back-link {{
      display: inline-block;
      margin-bottom: 1rem;
      font-size: 0.95rem;
      color: #003366;
      text-decoration: none;
      font-weight: bold;
    }}
  </style>
</head>
<body>
  
  <h1>Households Without Internet by County – {state_name}</h1>
  <div class="container">
    <div class="map-column">
      <iframe src="../internet-maps/{fips_code}.html" title="Map of {state_name}"></iframe>
    </div>
    <div class="sidebar">
      <iframe src="../internet-charts/{chart_filename}" alt="Internet Access Chart for {state_name}">
      <div class="caption">

      </div>
    </div>
  </div>
</body>
</html>
')

  write_file(html_content, path(output_dir, paste0(fips_code, ".html")))
})

```


# plumbing
```{r}


 
v <- load_variables(2023, "acs5", cache = TRUE)



plumbing_data <- get_acs(
  geography = "county",
  variables = c(
    total = "B25047_001",
    no_plumbing = "B25047_003"
  ),
  year = 2023,
  survey = "acs5",
  geometry = TRUE
)

plumbing_clean <- plumbing_data %>%
  select(GEOID, NAME, variable, estimate, geometry) %>%
  pivot_wider(names_from = variable, values_from = estimate) %>%
  mutate(
    pct_no_plumbing = no_plumbing / total,
    state_fips = substr(GEOID, 1, 2)
  )

# -------------------- 2. SHIFT GEOMETRY --------------------
shift_geometry <- function(sf_obj) {
  alaska <- sf_obj %>% filter(state_fips == "02") %>% st_transform(2163)
  hawaii <- sf_obj %>% filter(state_fips == "15") %>% st_transform(2163)
  mainland <- sf_obj %>% filter(!state_fips %in% c("02", "15")) %>% st_transform(4326)
  alaska_geom <- st_geometry(alaska) * 0.3 + c(-380000, -3000000)
  hawaii_geom <- st_geometry(hawaii) * 1.2 + c(4500000, -900000)
  st_crs(alaska_geom) <- 2163; st_crs(hawaii_geom) <- 2163
  alaska <- st_set_geometry(alaska, alaska_geom) %>% st_transform(4326)
  hawaii <- st_set_geometry(hawaii, hawaii_geom) %>% st_transform(4326)
  bind_rows(mainland, alaska, hawaii) %>% st_as_sf()
}

plumbing_shifted <- shift_geometry(plumbing_clean)

# -------------------- 3. STATE GEOMETRY --------------------
state_geom_plumbing <- states(cb = TRUE, year = 2023) %>%
  filter(!STATEFP %in% c("72", "78")) %>%
  select(state_fips = STATEFP, geometry) %>%
  mutate(link = paste0("plumbing-pages/", state_fips, ".html"))

state_geom_plumbing <- shift_geometry(state_geom_plumbing)

# -------------------- 4. WHITE MASK --------------------
world_box <- st_as_sfc(st_bbox(c(xmin = -180, ymin = -90, xmax = 180, ymax = 90)), crs = 4326)
us_box <- st_as_sfc(st_bbox(c(xmin = -130, ymin = 15, xmax = -60, ymax = 55)), crs = 4326)
mask_polygon <- st_difference(st_make_valid(world_box), st_make_valid(us_box)) %>%
  st_collection_extract("POLYGON") %>%
  st_set_crs(4326)
vals <- plumbing_shifted$pct_no_plumbing
max_val <- max(vals, na.rm = TRUE)

# Create 10 equal-width bins between 0 and max
breaks <- seq(0, ceiling(max_val * 100) / 100, length.out = 11)  # 10 breaks = 11 endpoints

colors <- colorRampPalette(brewer.pal(9, "OrRd"))(length(breaks) - 1)

pal <- colorBin(colors, domain = vals, bins = breaks)

plumbing_map <- leaflet(options = leafletOptions(
  minZoom = 4, maxZoom = 4,
  zoomControl = FALSE, dragging = FALSE,
  scrollWheelZoom = FALSE, doubleClickZoom = FALSE
)) %>%
  addTiles(urlTemplate = "") %>%
  addRectangles(lng1 = -180, lat1 = -90, lng2 = 180, lat2 = 90,
                fillColor = "white", fillOpacity = 1, stroke = FALSE) %>%
  addPolygons(data = mask_polygon, fillColor = "white", color = "white", weight = 0, fillOpacity = 1) %>%
  addPolygons(
    data = plumbing_shifted,
    fillColor = ~pal(pct_no_plumbing),
    color = "white", weight = 0.3, fillOpacity = 0.9,
    label = ~paste0(NAME, ": ", round(pct_no_plumbing * 100, 2), "%"),
    highlightOptions = highlightOptions(weight = 1, color = "black", bringToFront = TRUE)
  ) %>%
  addPolygons(
    data = state_geom_plumbing,
    fillOpacity = 0, color = "black", weight = 1,
    layerId = ~link,
    highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
  ) %>%
  addLegend(
    position = "topright", colors = colors,

labels = paste0(round(breaks[-length(breaks)] * 100), "%"),
title = "No Complete Plumbing (2023)", opacity = 1
  ) %>%
  setView(lng = -98.5, lat = 39.8, zoom = 8)

# -------------------- 6. JS CLICK HANDLER --------------------
plumbing_map <- onRender(plumbing_map, "
  function(el, x) {
    var map = this;
    var hash = window.location.hash;
    map.eachLayer(function(layer) {
      if (layer.options && layer.options.layerId) {
        layer.on('click', function(e) {
          window.top.location.href = layer.options.layerId + hash;
        });
      }
    });
  }
")

# -------------------- 7. SAVE --------------------
saveWidget(
  widget = plumbing_map,
  file = "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/plumbing-map.html",
  selfcontained = FALSE
)


# STATE MAPS

walk(unique(plumbing_clean$state_fips), function(fips) {
  state_data <- plumbing_clean %>%
    filter(state_fips == fips)

  vals <- state_data$pct_no_plumbing
  vals <- vals[is.finite(vals) & vals > 0]

  if (length(unique(vals)) < 2) return(NULL)

  breaks <- pretty(vals) 
  colors <- colorRampPalette(brewer.pal(9, "YlOrRd"))(length(breaks) - 1)
  pal <- colorBin(palette = colors, domain = vals, bins = breaks)

  leaflet_map <- leaflet(state_data, options = leafletOptions(minZoom = 5, maxZoom = 8)) %>%
    addProviderTiles("CartoDB.PositronNoLabels") %>%
    addPolygons(
      fillColor = ~pal(pct_no_plumbing),
      fillOpacity = 0.9,
      color = "white",
      weight = 1,
      label = ~paste0(NAME, ": ", round(pct_no_plumbing * 100, 1), "%"),
      highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
    ) %>%
    addLegend(
      position = "topright",
      colors = colors,
      labels = paste0(round(breaks[-length(breaks)] * 100, 1), "%"),
      title = "Households Without Complete Plumbing (2023)",
      opacity = 1
    )

  saveWidget(
    widget = leaflet_map,
    file = paste0(
      "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/plumbing-maps/",
      fips, ".html"
    ),
    selfcontained = FALSE
  )
})




# STATE PAGES PLUMBING

library(fs)
library(glue)
library(readr)
library(stringr)
library(fs)
library(glue)
library(readr)
library(stringr)

input_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/plumbing-maps"
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/plumbing-pages/"

# List HTML files
html_files <- dir_ls(input_dir, regexp = "\\.html$")

walk(html_files, function(file_path) {
  fips_code <- path_file(file_path) %>% path_ext_remove()

  html_content <- glue('
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Households Without Complete Plumbing Map – State {fips_code}</title>
  <style>
    body {{
      margin: 0;
      padding: 1.5rem;
      font-family: sans-serif;
      background-color: #f2f2f2;
    }}
    h1 {{
      font-size: 1.3rem;
      margin-bottom: 1rem;
    }}
    .container {{
      display: flex;
      gap: 2rem;
    }}
    .map-column {{
      flex: 1;
    }}
    .sidebar {{
      flex: 1;
    }}
    iframe {{
      width: 100%;
      height: 600px;
      border: none;
    }}
    a#back-link {{
      display: inline-block;
      margin-bottom: 1rem;
      font-size: 0.95rem;
      color: #003366;
      text-decoration: none;
      font-weight: bold;
    }}
  </style>
</head>
<body>
  
  <h1>Households Without Complete Plumbing by County – State {fips_code}</h1>
  <div class="container">
    <div class="map-column">
      <iframe src="../plumbing-maps/{fips_code}.html" title="Map of State {fips_code}"></iframe>
    </div>
    <div class="sidebar">
      <!-- You can add text, links, charts, etc. here later -->
    </div>
  </div>
</body>
</html>
')

  write_file(html_content, path(output_dir, paste0(fips_code, ".html")))
})




```

# new houses rankings (plumbing)

```{r}

output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/newhouses-tables/"


year <- 2023
states <- state.name

walk(states, function(state) {
  cat("Processing", state, "...\n")
  
  tryCatch({
    # 1. Get total and recent housing data
    housing_data <- get_acs(
      geography = "county",
      state = state,
      year = year,
      survey = "acs5",
      variables = c(
        total_units = "B25034_001",
        built_2014_or_later = "B25034_002",
        built_2010_2013 = "B25034_003"
      ),
      cache_table = TRUE
    )

    # 2. Pivot and compute %
    rankings <- housing_data %>%
      select(NAME, variable, estimate) %>%
      pivot_wider(names_from = variable, values_from = estimate) %>%
      mutate(
        built_since_2010 = built_2014_or_later + built_2010_2013,
        pct_built_since_2010 = 100 * built_since_2010 / total_units
      ) %>%
      arrange(desc(pct_built_since_2010))

    # 3. Generate HTML list of all counties
    list_items <- paste0(
      "<li><strong>", rankings$NAME, ":</strong> ",
      sprintf("%.1f", rankings$pct_built_since_2010), "%</li>"
    )

    widget_html <- glue('
<div class="ranking-widget">
  <h3>Percent of Housing Units Built Since 2010 by County</h3>
  <ul>
    {paste(list_items, collapse = "\n    ")}
  </ul>
</div>
')

    # 4. Save to file
    state_slug <- tolower(gsub(" ", "_", state))
    output_file <- file.path(output_dir, paste0(state_slug, "_2010_build_rankings.html"))
    write_file(widget_html, output_file)

  }, error = function(e) {
    message("Failed for ", state, ": ", e$message)
  })
})



input_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/plumbing-maps"
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/plumbing-pages/"
housing_table_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/facts-tables-housing"

# FIPS to state name lookup
# List .html files in the plumbing maps folder
html_files <- dir_ls(input_dir, regexp = "\\.html$")

walk(html_files, function(file_path) {
  fips_code <- path_file(file_path) %>% path_ext_remove()


  # Read interactive housing table for the state
  table_path <- file.path(housing_table_dir, paste0(fips_code, ".html"))
  housing_widget <- if (file_exists(table_path)) {
    glue('<iframe src="../facts-tables-housing/{fips_code}.html" title="Housing Table" style="width:100%; height:600px; border:none;"></iframe>')
  } else {
    "<p>No recent housing table available for this state.</p>"
  }

  # Build the full HTML page
  html_content <- glue('
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Households Without Complete Plumbing Map – {state_name}</title>
  <style>
    body {{
      margin: 0;
      padding: 1.5rem;
      font-family: sans-serif;
      background-color: #f2f2f2;
    }}
    h1 {{
      font-size: 1.3rem;
      margin-bottom: 1rem;
    }}
    .container {{
      display: flex;
      gap: 2rem;
    }}
    .map-column {{
      flex: 1;
    }}
    .sidebar {{
      flex: 1;
    }}
    iframe {{
      width: 100%;
      height: 600px;
      border: none;
    }}
    ul {{
      padding-left: 1.2rem;
    }}
    .ranking-widget {{
      background-color: #fff;
      border: 1px solid #ccc;
      padding: 1rem;
      border-radius: 6px;
    }}
    a#back-link {{
      display: inline-block;
      margin-bottom: 1rem;
      font-size: 0.95rem;
      color: #003366;
      text-decoration: none;
      font-weight: bold;
    }}
  </style>
</head>
<body>

  <h1>Households Without Complete Plumbing by County – {state_name}</h1>
  <div class="container">
    <div class="map-column">
      <iframe src="../plumbing-maps/{fips_code}.html" title="Map of {state_name}"></iframe>
    </div>
    <div class="sidebar">
      {housing_widget}
    </div>
  </div>
</body>
</html>
')

  write_file(html_content, path(output_dir, paste0(fips_code, ".html")))
})


get_acs(
  geography = "county",
  state = "OH",
  county = "Delaware",
  year = 2023,
  survey = "acs5",
  table = "B25034"
)





# new housing tables 

output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/facts-tables-housing/"
dir.create(output_dir, showWarnings = FALSE)

# Get state FIPS
state_fips_codes <- tidycensus::fips_codes %>%
  distinct(state, state_code) %>%
  filter(state %in% states) %>%
  arrange(state) %>%
  pull(state_code)

walk2(states, state_fips_codes, function(state, state_fips) {
  cat("Processing", state, "\n")

  housing_data <- get_acs(
    geography = "county",
    state = state,
    year = 2023,
    survey = "acs5",
    variables = c(
      total_units = "B25034_001",
      built_2014_or_later = "B25034_002",
      built_2010_2013 = "B25034_003",
      owner_occupied = "B25003_002",
      total_occupied = "B25003_001",
      median_year_built = "B25035_001",
      total_pop = "B01003_001"
    ),
    cache_table = TRUE
  )

  table_data <- housing_data %>%
    select(NAME, variable, estimate) %>%
    pivot_wider(names_from = variable, values_from = estimate) %>%
    mutate(
      County = NAME,
      `% Built Since 2010` = round(100 * (built_2014_or_later + built_2010_2013) / total_units, 1),
      `% Owner-Occupied` = round(100 * owner_occupied / total_occupied, 1),
      `Median Year Built` = median_year_built,
      `Units per 1,000` = round(1000 * total_units / total_pop, 1)
    ) %>%
    select(
      County,
      `% Built Since 2010`,
      `% Owner-Occupied`,
      `Median Year Built`,
      `Units per 1,000`
    ) %>%
    arrange(desc(`% Built Since 2010`))

  # Create DT widget
  dt_widget <- datatable(
    table_data,
    rownames = FALSE,
    options = list(
      pageLength = 25,
      autoWidth = TRUE,
      dom = 'tip',
      ordering = TRUE
    ),
    class = "stripe hover compact"
  )

  saveWidget(
    dt_widget,
    file = file.path(output_dir, paste0(state_fips, ".html")),
    selfcontained = TRUE
  )
})

```


# departure time 
```{r}

depart_vars <- c(
  "B08132_002", "B08132_003", "B08132_004", "B08132_005",
  "B08132_006", "B08132_007", "B08132_008", "B08132_009",
  "B08132_010", "B08132_011", "B08132_012", "B08132_013"
)

depart_data <- get_acs(
  geography = "county",
  variables = depart_vars,
  year = 2023,
  survey = "acs5",
  geometry = TRUE
)

# -------------------- 3. CLEAN --------------------
depart_clean <- depart_data %>%
  mutate(time = case_when(
    variable == "B08132_002" ~ "Before 6:00 AM",
    variable == "B08132_003" ~ "6:00–6:29 AM",
    variable == "B08132_004" ~ "6:30–6:59 AM",
    variable == "B08132_005" ~ "7:00–7:29 AM",
    variable == "B08132_006" ~ "7:30–7:59 AM",
    variable == "B08132_007" ~ "8:00–8:29 AM",
    variable == "B08132_008" ~ "8:30–8:59 AM",
    variable == "B08132_009" ~ "9:00–9:59 AM",
    variable == "B08132_010" ~ "10:00–10:59 AM",
    variable == "B08132_011" ~ "11:00–11:59 AM",
    variable == "B08132_012" ~ "12:00 PM or later",
    variable == "B08132_013" ~ "Worked from home"
  )) %>%
  select(GEOID, NAME, estimate, time, geometry)

time_midpoints <- c(
  "Before 6:00 AM" = 500,       # 5:30 AM
  "6:00–6:29 AM" = 615,         # 6:15 AM
  "6:30–6:59 AM" = 645,
  "7:00–7:29 AM" = 705,
  "7:30–7:59 AM" = 735,
  "8:00–8:29 AM" = 825,
  "8:30–8:59 AM" = 855,
  "9:00–9:59 AM" = 930,
  "10:00–10:59 AM" = 1050,
  "11:00–11:59 AM" = 1110,
  "12:00 PM or later" = 1200,
  "Worked from home" = NA       # Optional: exclude from avg
)

# Step 2: Compute weighted average
depart_avg <- depart_clean %>%
  filter(time != "Worked from home") %>%
  mutate(
    minutes = time_midpoints[time],
    weighted = estimate * minutes
  ) %>%
  group_by(GEOID, NAME) %>%
  summarize(
    avg_departure = sum(weighted, na.rm = TRUE) / sum(estimate, na.rm = TRUE),
    .groups = "drop"
  )

geoms <- depart_clean %>%
  select(GEOID, geometry) %>%
  distinct(GEOID, .keep_all = TRUE) %>%
  st_drop_geometry()

# Step 2: Join with computed averages and re-add geometry
depart_avg_geom <- right_join(geoms, depart_avg, by = "GEOID") %>%
  st_as_sf() %>%
  mutate(state_fips = substr(GEOID, 1, 2))

# -------------------- 4. SHIFT GEOMETRY --------------------
shift_geometry <- function(sf_obj) {
  alaska <- sf_obj %>% filter(state_fips == "02") %>% st_transform(2163)
  hawaii <- sf_obj %>% filter(state_fips == "15") %>% st_transform(2163)
  mainland <- sf_obj %>% filter(!state_fips %in% c("02", "15")) %>% st_transform(4326)
  alaska_geom <- st_geometry(alaska) * 0.3 + c(-380000, -3000000)
  hawaii_geom <- st_geometry(hawaii) * 1.2 + c(4500000, -900000)
  st_crs(alaska_geom) <- 2163; st_crs(hawaii_geom) <- 2163
  alaska <- st_set_geometry(alaska, alaska_geom) %>% st_transform(4326)
  hawaii <- st_set_geometry(hawaii, hawaii_geom) %>% st_transform(4326)
  bind_rows(mainland, alaska, hawaii) %>% st_as_sf()
}

depart_shifted <- shift_geometry(depart_avg_geom)

# -------------------- 5. STATE POLYGONS --------------------
state_geom <- states(cb = TRUE, year = 2023) %>%
  filter(!STATEFP %in% c("72", "78")) %>%
  select(state_fips = STATEFP, geometry) %>%
  mutate(link = paste0("departure-pages/", state_fips, ".html"))

state_geom <- shift_geometry(state_geom)

# -------------------- 6. COLOR --------------------
# These breaks must **start below 661** and end above 1036
time_breaks <- c(600, 630, 660, 690, 720, 810, 840, 900, 1020, 1080)  # covers all possible values
time_labels <- c(
  "Before 6:00 AM", "6:00 AM", "6:30 AM", "7:00 AM", "7:30 AM",
  "8:00 AM", "8:30 AM", "9:00 AM", "10:00 AM", "After 11:00 AM"
)

# Recode and set time_group as properly ordered factor
depart_shifted <- depart_shifted %>%
  mutate(
    time_group = case_when(
      avg_departure < 600 ~ "Before 6:00 AM",
      avg_departure < 630 ~ "6:00 AM",
      avg_departure < 660 ~ "6:30 AM",
      avg_departure < 690 ~ "7:00 AM",
      avg_departure < 720 ~ "7:30 AM",
      avg_departure < 810 ~ "8:00 AM",
      avg_departure < 840 ~ "8:30 AM",
      avg_departure < 900 ~ "9:00 AM",
      avg_departure < 1020 ~ "10:00 AM",
      TRUE ~ "After 11:00 AM"
    ),
    time_group = factor(time_group, levels = time_labels)
  )

# Set up color palette using that factor
pal <- colorFactor(
  palette = "YlGnBu",
  domain = factor(time_labels, levels = time_labels),  # force it
  ordered = TRUE
)
# -------------------- 7. MASK --------------------
world_box <- st_as_sfc(st_bbox(c(xmin = -180, ymin = -90, xmax = 180, ymax = 90)), crs = 4326)
us_box <- st_as_sfc(st_bbox(c(xmin = -130, ymin = 15, xmax = -60, ymax = 55)), crs = 4326)
mask_polygon <- st_difference(st_make_valid(world_box), st_make_valid(us_box)) %>%
  st_collection_extract("POLYGON") %>%
  st_set_crs(4326)

# -------------------- 8. MAP --------------------
departure_map <- leaflet(options = leafletOptions(
  minZoom = 4, maxZoom = 4, zoomControl = FALSE,
  dragging = FALSE, scrollWheelZoom = FALSE, doubleClickZoom = FALSE
)) %>%
  addTiles(urlTemplate = "") %>%
  addRectangles(lng1 = -180, lat1 = -90, lng2 = 180, lat2 = 90,
                fillColor = "white", fillOpacity = 1, stroke = FALSE) %>%
  addPolygons(data = mask_polygon, fillColor = "white", color = "white", weight = 0, fillOpacity = 1) %>%
  addPolygons(
    data = depart_shifted,
    fillColor = ~pal(time_group),
    color = "white", weight = 0.3, fillOpacity = 0.9,
    label = ~paste0(NAME, ": ", time_group),
    highlightOptions = highlightOptions(weight = 1, color = "black", bringToFront = TRUE)
  ) %>%
  addPolygons(
    data = state_geom,
    fillOpacity = 0, color = "black", weight = 1,
    layerId = ~link,
    highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
  ) %>%
  addLegend(
  position = "topright",
  pal = pal,
  values = factor(time_labels, levels = time_labels),
  title = "Avg. Work Departure Time (2023)",
  opacity = 1
) %>%
  setView(lng = -98.5, lat = 39.8, zoom = 8)

# -------------------- 9. CLICK HANDLER --------------------
departure_map <- htmlwidgets::onRender(departure_map, "
  function(el, x) {
    var map = this;
    var hash = window.location.hash;
    map.eachLayer(function(layer) {
      if (layer.options && layer.options.layerId) {
        layer.on('click', function(e) {
          window.top.location.href = layer.options.layerId + hash;
        });
      }
    });
  }
")

# -------------------- 10. SAVE --------------------
saveWidget(
  widget = departure_map,
  file = '/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/departure-map.html',
  selfcontained = FALSE
)






# DEPARTURE STATE MAPS


# Define consistent label order and palette
time_labels <- c(
  "Before 6:00 AM", "6:00 AM", "6:30 AM", "7:00 AM", "7:30 AM",
  "8:00 AM", "8:30 AM", "9:00 AM", "10:00 AM", "After 11:00 AM"
)

pal <- colorFactor("YlGnBu", domain = factor(time_labels, levels = time_labels), ordered = TRUE)

# Generate a map for each state
walk(unique(depart_shifted$state_fips), function(fips) {
  state_data <- depart_shifted %>%
    filter(state_fips == fips)

  if (nrow(state_data) == 0 || all(is.na(state_data$time_group))) return(NULL)

  # Re-factor just in case
  state_data$time_group <- factor(state_data$time_group, levels = time_labels)

  leaflet_map <- leaflet(state_data, options = leafletOptions(minZoom = 5, maxZoom = 8)) %>%
    addProviderTiles("CartoDB.PositronNoLabels") %>%
    addPolygons(
      fillColor = ~pal(time_group),
      fillOpacity = 0.9,
      color = "white",
      weight = 1,
      label = ~paste0(NAME, ": ", time_group),
      highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
    ) %>%
    addLegend(
      position = "topright",
      pal = pal,
      values = factor(time_labels, levels = time_labels),
      title = "Avg. Work Departure Time (2023)",
      opacity = 1
    )

  saveWidget(
    widget = leaflet_map,
    file = paste0(
      "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/departure-maps/",
      fips, ".html"
    ),
    selfcontained = FALSE
  )
})


# STATE PAGEs DEPARTURE  

library(fs)
library(glue)
library(readr)
library(stringr)
library(fs)
library(glue)
library(readr)
library(stringr)

input_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/departure-maps"
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/departure-pages/"

# List HTML files
html_files <- dir_ls(input_dir, regexp = "\\.html$")

walk(html_files, function(file_path) {
  fips_code <- path_file(file_path) %>% path_ext_remove()

  html_content <- glue('
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Avg. Work Departure Time Map – State {fips_code} (2023) </title>
  <style>
    body {{
      margin: 0;
      padding: 1.5rem;
      font-family: sans-serif;
      background-color: #f2f2f2;
    }}
    h1 {{
      font-size: 1.3rem;
      margin-bottom: 1rem;
    }}
    .container {{
      display: flex;
      gap: 2rem;
    }}
    .map-column {{
      flex: 1;
    }}
    .sidebar {{
      flex: 1;
    }}
    iframe {{
      width: 100%;
      height: 600px;
      border: none;
    }}
    a#back-link {{
      display: inline-block;
      margin-bottom: 1rem;
      font-size: 0.95rem;
      color: #003366;
      text-decoration: none;
      font-weight: bold;
    }}
  </style>
</head>
<body>
  
  <h1> Avg. Work Departure Time Map – State {fips_code} (2023)</h1>
  <div class="container">
    <div class="map-column">
      <iframe src="../departure-maps/{fips_code}.html" title="Map of State {fips_code}"></iframe>
    </div>
    <div class="sidebar">
      <!-- You can add text, links, charts, etc. here later -->
    </div>
  </div>
</body>
</html>
')

  write_file(html_content, path(output_dir, paste0(fips_code, ".html")))
})



```


# departure state page mode tables

```{r}
year <- 2023
states <- state.name
output_dir <- '/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/departure-mode-tables/'

walk(states, function(state) {
  cat("Processing", state, "...\n")

  tryCatch({
    commute_data <- get_acs(
      geography = "county",
      state = state,
      year = year,
      survey = "acs5",
      table = "B08301",
      cache_table = TRUE
    )

    commute_wide <- commute_data %>%
      select(NAME, variable, estimate) %>%
      pivot_wider(names_from = variable, values_from = estimate)

    rankings <- commute_wide %>%
      mutate(
        `Drive Alone`     = 100 * B08301_003 / B08301_001,
        Carpool           = 100 * B08301_004 / B08301_001,
        Transit           = 100 * B08301_010 / B08301_001,
        Walk              = 100 * B08301_018 / B08301_001,
        Bike              = 100 * B08301_019 / B08301_001,
        `Work from Home`  = 100 * B08301_021 / B08301_001
      ) %>%
      mutate(across(
  c(`Drive Alone`, Carpool, Transit, Walk, Bike, `Work from Home`),
  ~ paste0(round(.x, 1), "%")
)) %>%
      select(County = NAME, `Drive Alone`, Carpool, Transit, Walk, Bike, `Work from Home`)

    # Save as interactive table
    table_widget <- datatable(
      rankings,
      options = list(pageLength = 50),
      rownames = FALSE
    )

    state_slug <- tolower(gsub(" ", "_", state))
    output_file <- file.path(output_dir, paste0(state_slug, "_commute_modes.html"))
    saveWidget(table_widget, file = output_file, selfcontained = TRUE)

  }, error = function(e) {
    message("Failed for ", state, ": ", e$message)
  })
})


library(fs)
library(glue)
library(readr)
library(stringr)

input_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/departure-maps"
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/departure-pages/"
widget_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/departure-mode-tables"

# Load state FIPS to name mapping
fips_lookup <- tidycensus::fips_codes %>%
  filter(state_code %in% sprintf("%02d", 1:56)) %>%
  distinct(state_code, state_name) %>%
  group_by(state_code) %>%
  slice(1) %>%
  ungroup() %>%
  mutate(
    fips = state_code,
    state_slug = tolower(gsub(" ", "_", state_name))
  )

# List HTML files
html_files <- dir_ls(input_dir, regexp = "\\.html$")

walk(html_files, function(file_path) {
  fips_code <- path_file(file_path) %>% path_ext_remove()

  # Lookup state slug
  state_slug <- fips_lookup %>%
    filter(fips == fips_code) %>%
    pull(state_slug)

  # Path to commute mode widget iframe source
  iframe_src <- paste0("../departure-pages/", state_slug, "_commute_modes.html")

  # Build HTML
  html_content <- glue('
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Avg. Work Departure Time Map – State {fips_code} (2023)</title>
  <style>
    body {{
      margin: 0;
      padding: 1.5rem;
      font-family: sans-serif;
      background-color: #f2f2f2;
    }}
    h1 {{
      font-size: 1.3rem;
      margin-bottom: 1rem;
    }}
    .container {{
      display: flex;
      gap: 2rem;
    }}
    .map-column {{
      flex: 1;
    }}
    .sidebar {{
      flex: 1;
      background-color: #fff;
      padding: 1rem;
      border: 1px solid #ccc;
      border-radius: 6px;
    }}
    iframe {{
      width: 100%;
      height: 600px;
      border: none;
    }}
    .sidebar h2 {{
      font-size: 1.1rem;
      margin-top: 0;
      margin-bottom: 1rem;
    }}
  </style>
</head>
<body>
  <h1>Avg. Work Departure Time Map – State {fips_code} (2023)</h1>
  <div class="container">
    <div class="map-column">
      <iframe src="../departure-maps/{fips_code}.html" title="Map of State {fips_code}"></iframe>
    </div>
    <div class="sidebar">
      <h2>Commute Mode Breakdown by County</h2>
      <iframe src="{iframe_src}" title="Commute Mode Table for {state_slug}"></iframe>
    </div>
  </div>
</body>
</html>
')

  # Save page
  write_file(html_content, path(output_dir, paste0(fips_code, ".html")))
})
```


# immigrant influx 
```{r}
vars <- c(total = "B05001_001", foreign = "B05001_006")

foreign_2020 <- get_acs(
  geography = "county",
  variables = vars,
  year = 2020,
  survey = "acs5",
  geometry = TRUE
)

foreign_2023 <- get_acs(
  geography = "county",
  variables = vars,
  year = 2023,
  survey = "acs5",
  geometry = TRUE
)

# -------------------- 2. CLEAN FUNCTION (USING 'total', 'foreign') --------------------
clean_foreign <- function(df, year) {
  df %>%
    st_drop_geometry() %>%
    select(GEOID, variable, estimate) %>%
    pivot_wider(names_from = variable, values_from = estimate) %>%
    mutate(year = year, share = foreign / total)
}

f20 <- clean_foreign(foreign_2020, 2020)
f23 <- clean_foreign(foreign_2023, 2023)

# -------------------- 3. CALCULATE CHANGE --------------------
foreign_change <- left_join(f23, f20, by = "GEOID", suffix = c("_2023", "_2020")) %>%
  mutate(change = share_2023 - share_2020) %>%
  distinct(GEOID, .keep_all = TRUE)

# -------------------- 4. JOIN GEOMETRY BACK --------------------
foreign_map <- foreign_2023 %>%
  filter(variable == "total") %>%
  select(GEOID, NAME, geometry) %>%
  left_join(foreign_change, by = "GEOID") %>%
  mutate(state_fips = substr(GEOID, 1, 2))

# -------------------- 5. SHIFT GEOMETRY FUNCTION --------------------
shift_geometry <- function(sf_obj) {
  alaska <- sf_obj %>% filter(state_fips == "02") %>% st_transform(2163)
  hawaii <- sf_obj %>% filter(state_fips == "15") %>% st_transform(2163)
  mainland <- sf_obj %>% filter(!state_fips %in% c("02", "15")) %>% st_transform(4326)
  alaska_geom <- st_geometry(alaska) * 0.3 + c(-380000, -3000000)
  hawaii_geom <- st_geometry(hawaii) * 1.2 + c(4500000, -900000)
  st_crs(alaska_geom) <- 2163; st_crs(hawaii_geom) <- 2163
  alaska <- st_set_geometry(alaska, alaska_geom) %>% st_transform(4326)
  hawaii <- st_set_geometry(hawaii, hawaii_geom) %>% st_transform(4326)
  bind_rows(mainland, alaska, hawaii) %>% st_as_sf()
}

foreign_shifted <- shift_geometry(foreign_map)

# -------------------- 6. STATE GEOMETRY (for clickable layer) --------------------
state_geom <- states(cb = TRUE, year = 2023) %>%
  filter(!STATEFP %in% c("72", "78")) %>%
  select(state_fips = STATEFP, geometry) %>%
  mutate(link = paste0("immigrant-pages/", state_fips, ".html"))

state_geom_shifted <- shift_geometry(state_geom)

# -------------------- 7. WHITE MASK --------------------
world_box <- st_as_sfc(st_bbox(c(xmin = -180, ymin = -90, xmax = 180, ymax = 90)), crs = 4326)
us_box <- st_as_sfc(st_bbox(c(xmin = -130, ymin = 15, xmax = -60, ymax = 55)), crs = 4326)
mask_polygon <- st_difference(st_make_valid(world_box), st_make_valid(us_box)) %>%
  st_collection_extract("POLYGON") %>%
  st_set_crs(4326)

# -------------------- 8. COLOR SCALE --------------------
vals <- foreign_shifted$change
breaks <- seq(-0.2, 0.15, by = 0.02)
colors <- colorRampPalette(brewer.pal(11, "PuOr"))(length(breaks) - 1)
pal <- colorBin(colors, domain = vals, bins = breaks)

# -------------------- 9. MAP --------------------
immigrant_map <- leaflet(options = leafletOptions(
  minZoom = 4, maxZoom = 4, zoomControl = FALSE,
  dragging = FALSE, scrollWheelZoom = FALSE, doubleClickZoom = FALSE
)) %>%
  addTiles(urlTemplate = "") %>%
  addRectangles(lng1 = -180, lat1 = -90, lng2 = 180, lat2 = 90,
                fillColor = "white", fillOpacity = 1, stroke = FALSE) %>%
  addPolygons(data = mask_polygon, fillColor = "white", color = "white", weight = 0, fillOpacity = 1) %>%
  addPolygons(
    data = foreign_shifted,
    fillColor = ~pal(change),
    color = "white", weight = 0.3, fillOpacity = 0.9,
    label = ~paste0(NAME, ": ", round(change * 100, 2), " percentage points"),
    highlightOptions = highlightOptions(weight = 1, color = "black", bringToFront = TRUE)
  ) %>%
  addPolygons(
    data = state_geom_shifted,
    fillOpacity = 0, color = "black", weight = 1,
    layerId = ~link,
    highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
  ) %>%
  addLegend(
    position = "topright",
    pal = pal,
    values = vals,
    title = "Change in Foreign-Born Share (2020–2023)",
    labFormat = labelFormat(suffix = "%", transform = function(x) round(x * 100)),
    opacity = 1
  ) %>%
  setView(lng = -98.5, lat = 39.8, zoom = 8)

# -------------------- 10. JS CLICK HANDLER --------------------
immigrant_map <- onRender(immigrant_map, "
  function(el, x) {
    var map = this;
    map.eachLayer(function(layer) {
      if (layer.options && layer.options.layerId) {
        layer.on('click', function(e) {
          window.top.location.href = layer.options.layerId;
        });
      }
    });
  }
")

# -------------------- 11. SAVE --------------------
saveWidget(
  widget = immigrant_map,
  file = '/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/immigrant-change-map.html',
  selfcontained = FALSE
)




```

# misc front page language widget

```{r}

library(tidycensus)
library(dplyr)
library(stringr)
library(purrr)
library(tidyr)
library(jsonlite)
library(htmltools)

year <- 2023
survey <- "acs5"

# Pull state and county language data
state_language <- get_acs(
  geography = "state",
  table = "B16001",
  year = year,
  survey = survey,
  cache_table = TRUE
)

county_language <- get_acs(
  geography = "county",
  table = "B16002",
  year = year,
  survey = survey,
  cache_table = TRUE
)

# Language groupings for B16002
grouped_b16002 <- load_variables(year, survey, cache = TRUE) %>%
  filter(str_detect(name, "B16002_")) %>%
  select(variable = name, label) %>%
  filter(variable != "B16002_001") %>%
  mutate(group = case_when(
    variable == "B16002_002" ~ "English only",
    variable %in% c("B16002_003", "B16002_004", "B16002_005") ~ "Spanish",
    variable %in% c("B16002_006", "B16002_007", "B16002_008") ~ "French, Haitian, Cajun",
    variable %in% c("B16002_009", "B16002_010", "B16002_011") ~ "German or West Germanic",
    variable %in% c("B16002_012", "B16002_013", "B16002_014") ~ "Russian, Polish, Slavic",
    variable %in% c("B16002_015", "B16002_016", "B16002_017") ~ "Other Indo-European",
    variable %in% c("B16002_018", "B16002_019", "B16002_020") ~ "Korean",
    variable %in% c("B16002_021", "B16002_022", "B16002_023") ~ "Chinese",
    variable %in% c("B16002_024", "B16002_025", "B16002_026") ~ "Vietnamese",
    variable %in% c("B16002_027", "B16002_028", "B16002_029") ~ "Tagalog",
    variable %in% c("B16002_030", "B16002_031", "B16002_032") ~ "Other Asian/Pacific",
    variable %in% c("B16002_033", "B16002_034", "B16002_035") ~ "Arabic",
    variable %in% c("B16002_036", "B16002_037", "B16002_038") ~ "Other/Unspecified",
    TRUE ~ "Other"
  ))

# Clean and group county-level data
county_grouped <- county_language %>%
  left_join(grouped_b16002, by = "variable") %>%
  filter(!is.na(group)) %>%
  group_by(NAME, group) %>%
  summarise(estimate = sum(estimate, na.rm = TRUE), .groups = "drop") %>%
  group_by(NAME) %>%
  mutate(total = sum(estimate), pct = round(100 * estimate / total, 2)) %>%
  ungroup()

# Clean and group state-level data for default option
state_grouped <- state_language %>%
  left_join(grouped_b16002, by = "variable") %>%
  filter(!is.na(group)) %>%
  group_by(NAME, group) %>%
  summarise(estimate = sum(estimate, na.rm = TRUE), .groups = "drop") %>%
  group_by(NAME) %>%
  mutate(total = sum(estimate), pct = round(100 * estimate / total, 2),
         county = "Statewide") %>%
  ungroup()

# Save master JSONs if needed
write_json(county_grouped, "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/lang-widget/county_language_grouped.json", pretty = TRUE)
write_json(state_grouped, "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/lang-widget/state_language_grouped.json", pretty = TRUE)

# Make widget files
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/lang-widget"
dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)

state_data <- read_json("/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/lang-widget/state_language_grouped.json", simplifyVector = TRUE)
county_data <- read_json("/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/lang-widget/county_language_grouped.json", simplifyVector = TRUE)

# FIPS lookup
fips_lookup <- tibble::tibble(
  fips = names(fips_to_state),
  state = unname(fips_to_state)
)

unique_states <- unique(state_data$NAME)

walk(unique_states, function(state_name) {
  fips <- fips_lookup$fips[fips_lookup$state == state_name]

  if (length(fips) == 0 || is.na(fips)) {
    warning("⚠️ No FIPS match for state: ", state_name)
    return()
  }

  # Data for this state
  state_filtered <- state_data %>%
    filter(NAME == state_name) %>%
    mutate(NAME = state_name, county = "Statewide")

  county_filtered <- county_data %>%
    filter(str_ends(NAME, state_name)) %>%
    mutate(county = str_remove(NAME, paste0(", ", state_name)))

  # Combine state as default row
  combined_data <- bind_rows(state_filtered, county_filtered)

  # Write per-state JSON files
  write_json(state_filtered, file.path(output_dir, paste0(fips, "_state.json")), pretty = TRUE)
  write_json(combined_data, file.path(output_dir, paste0(fips, "_county.json")), pretty = TRUE)

  # HTML page with widget setup
  html_page <- tags$html(
    lang = "en",
    tags$head(
      tags$meta(charset = "utf-8"),
      tags$title(paste("Language Spoken at Home –", state_name)),
      tags$style(HTML("
        body { background-color: white; font-family: sans-serif; margin: 20px; }
        canvas { max-width: 100%; }
      ")),
      tags$script(src = "https://cdn.jsdelivr.net/npm/chart.js"),
      tags$script(src = "language-widget.js")
    ),
    tags$body(
      div(id = "langWidget", style = "max-width: 650px; margin: 20px auto;"),
      tags$script(HTML(glue("
        initLanguageWidget({{
          stateDataUrl: '{fips}_state.json',
          countyDataUrl: '{fips}_county.json',
          containerSelector: '#langWidget'
        }});
      ")))
    )
  )

  save_html(html_page, file = file.path(output_dir, paste0(fips, ".html")), background = "white")
  message("✅ Saved: ", state_name, " → ", fips, ".html")
})






# map


most_spoken_lang <- county_grouped %>%
  filter(group != "English only") %>%
  group_by(NAME) %>%
  slice_max(order_by = estimate, n = 1, with_ties = FALSE) %>%
  ungroup()


county_geom <- counties(cb = TRUE, year = 2023) %>%
  filter(!STATEFP %in% c("72", "78")) %>%
  select(GEOID, STATEFP, NAMELSAD, geometry) %>%
  left_join(fips_codes %>% select(STATEFP = state_code, state_name) %>% distinct(), by = "STATEFP") %>%
  mutate(NAME = str_c(NAMELSAD, ", ", state_name)) %>%
  select(GEOID, state_fips = STATEFP, NAME, geometry)

lang_data <- left_join(most_spoken_lang, county_geom, by = "NAME")


shift_geometry <- function(sf_obj) {
  alaska <- sf_obj %>% filter(state_fips == "02") %>% st_transform(2163)
  hawaii <- sf_obj %>% filter(state_fips == "15") %>% st_transform(2163)
  mainland <- sf_obj %>% filter(!state_fips %in% c("02", "15")) %>% st_transform(4326)
  alaska_geom <- st_geometry(alaska) * 0.3 + c(-380000, -3000000)
  hawaii_geom <- st_geometry(hawaii) * 1.2 + c(4500000, -900000)
  st_crs(alaska_geom) <- 2163; st_crs(hawaii_geom) <- 2163
  alaska <- st_set_geometry(alaska, alaska_geom) %>% st_transform(4326)
  hawaii <- st_set_geometry(hawaii, hawaii_geom) %>% st_transform(4326)
  bind_rows(mainland, alaska, hawaii) %>% st_as_sf()
}


drop_na_column <- function(df, column_name) {
  df %>% filter(!is.na(.data[[column_name]]))
}

lang_data <- drop_na_column(lang_data, "GEOID")


lang_data <- st_as_sf(lang_data)
lang_data <- st_transform(lang_data, crs = 4326)

lang_shifted <- shift_geometry(lang_data)



world_box <- st_as_sfc(st_bbox(c(xmin = -180, ymin = -90, xmax = 180, ymax = 90)), crs = 4326)
us_box <- st_as_sfc(st_bbox(c(xmin = -130, ymin = 15, xmax = -60, ymax = 55)), crs = 4326)
mask_polygon <- st_difference(st_make_valid(world_box), st_make_valid(us_box))
mask_polygon <- st_collection_extract(mask_polygon, "POLYGON")


lang_levels <- sort(unique(lang_shifted$group))
lang_palette <- setNames(RColorBrewer::brewer.pal(length(lang_levels), "Set3"), lang_levels)
pal <- colorFactor(palette = lang_palette, domain = lang_levels)


state_geom <- states(cb = TRUE, year = 2023) %>%
  filter(!STATEFP %in% c("72", "78")) %>%
  select(state_fips = STATEFP, geometry) %>%
  mutate(link = paste0("language-pages/", state_fips, ".html")) %>%
  shift_geometry()

lang_map <- leaflet(options = leafletOptions(
  minZoom = 4, maxZoom = 4,
  zoomControl = FALSE, dragging = FALSE, scrollWheelZoom = FALSE, doubleClickZoom = FALSE
)) %>%
  addTiles(urlTemplate = "") %>%
  addRectangles(
    lng1 = -180, lat1 = -90, lng2 = 180, lat2 = 90,
    fillColor = "white", fillOpacity = 1, stroke = FALSE
  ) %>%
  addPolygons(data = mask_polygon, fillColor = "white", color = "white", weight = 0, fillOpacity = 1) %>%
  addPolygons(
    data = lang_shifted,
    fillColor = ~pal(group),
    color = "white", weight = 0.3, fillOpacity = 0.9,
    label = ~paste0(NAME, ": ", group),
    highlightOptions = highlightOptions(weight = 1, color = "black", bringToFront = TRUE)
  ) %>%
  addPolygons(
    data = state_geom,
    fillOpacity = 0, color = "black", weight = 1, layerId = ~link,
    highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
  ) %>%
  addLegend(
    position = "topright",
    pal = pal, values = lang_shifted$group,
    title = "Most Spoken Language (Non-English)", opacity = 1
  ) %>%
  setView(lng = -98.5, lat = 39.8, zoom = 8) %>%
  onRender("
    function(el, x) {
      var map = this;
      var hash = window.location.hash;
      map.eachLayer(function(layer) {
        if (layer.options && layer.options.layerId) {
          layer.on('click', function(e) {
            window.top.location.href = layer.options.layerId + hash;
          });
        }
      });
    }
  ")

saveWidget(
  widget = lang_map,
  file = "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/language-mostspoken.html",
  selfcontained = FALSE
)



# state maps 
walk(unique(lang_data$state_fips), function(fips) {
  state_data <- lang_data %>%
    filter(state_fips == fips)

  if (nrow(state_data) == 0 || all(is.na(state_data$group))) return(NULL)

  # Set factor levels explicitly for consistency
  state_data$group <- factor(state_data$group, levels = lang_levels)

  leaflet_map <- leaflet(state_data, options = leafletOptions(minZoom = 5, maxZoom = 8)) %>%
    addProviderTiles("CartoDB.PositronNoLabels") %>%
    addPolygons(
      fillColor = ~pal(group),
      fillOpacity = 0.9,
      color = "white",
      weight = 1,
      label = ~paste0(NAME, ": ", group),
      highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
    ) %>%
    addLegend(
      position = "topright",
      pal = pal,
      values = state_data$group,
      title = "Most Spoken Language (Non-English)",
      opacity = 1
    )

  saveWidget(
    widget = leaflet_map,
    file = file.path(
      "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/lang-state-maps/",
      paste0(fips, ".html")
    ),
    selfcontained = FALSE
  )
})



# pages 



state_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/language-pages/"
fips_codes <- sprintf("%02d", 1:56)  # or use unique(state_fips) if you have data

walk(fips_codes, function(fips) {
  file_path <- file.path(state_dir, paste0(fips, ".html"))

  html <- paste0(
'<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>State Page</title>
  <style>
    body {
      margin: 2rem;
      font-family: sans-serif;
    }
    #wrapper {
      display: flex;
      gap: 1rem;
      align-items: flex-start;
    }
    iframe {
      border: none;
    }
    .map-column {
      width: 60%;
    }
    .chart-column {
      width: 40%;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
  </style>
</head>
<body>
<h1>Most Spoken Language (after English) by County - ', fips, '</h1>
  <div id="wrapper">
    <div class="map-column">
      <iframe
        src="../lang-state-maps/', fips, '.html"
        title="County Map"
        style="width: 100%; height: 500px;">
      </iframe>
    </div>

    <div class="chart-column">
      <iframe
        src="../lang-widget/', fips, '.html"
        title="County Table"
        style="width: 100%; height: 800px;">
      </iframe>
    </div>
  </div>
</body>
</html>'
  )

  writeLines(html, file_path)
  cat("✔️ Created:", file_path, "\n")
})



```


# crowding
```{r}



# 1. Load ACS overcrowding data
crowding_data <- get_acs(
  geography = "county",
  variables = c(
    total_units = "B25014_001",
    persons_1 = "B25014_002", persons_2 = "B25014_003",
    persons_3 = "B25014_004", persons_4 = "B25014_005",
    persons_5 = "B25014_006", persons_6 = "B25014_007",
    persons_7 = "B25014_008"
  ),
  year = 2023,
  survey = "acs5",
  geometry = TRUE
)

# 2. Clean and calculate average persons per room
crowding_clean <- crowding_data %>%
  select(GEOID, NAME, variable, estimate, geometry) %>%
  pivot_wider(names_from = variable, values_from = estimate) %>%
  mutate(
    state_fips = substr(GEOID, 1, 2),
    weighted_score = persons_1 * 0.25 + persons_2 * 0.75 + persons_3 * 1.25 +
                     persons_4 * 1.51 + persons_5 * 1.75 + persons_6 * 2.25 + persons_7 * 3,
    avg_ppr = weighted_score / total_units
  )

# 3. Create state polygons with links
state_geom <- tigris::states(cb = TRUE, year = 2023) %>%
  filter(!STATEFP %in% c("72", "78")) %>%
  select(state_fips = STATEFP, geometry) %>%
  mutate(link = paste0("crowding-pages/", state_fips, ".html"))

# 4. Shift Alaska and Hawaii
shift_geometry <- function(sf_obj) {
  alaska <- sf_obj %>% filter(state_fips == "02") %>% st_transform(2163)
  hawaii <- sf_obj %>% filter(state_fips == "15") %>% st_transform(2163)
  mainland <- sf_obj %>% filter(!state_fips %in% c("02", "15")) %>% st_transform(2163)

  alaska_geom <- st_geometry(alaska) * 0.3 + c(-380000, -3000000)
  hawaii_geom <- st_geometry(hawaii) * 1.2 + c(4500000, -900000)

  st_crs(alaska_geom) <- 2163
  st_crs(hawaii_geom) <- 2163

  alaska <- st_set_geometry(alaska, alaska_geom) %>% st_transform(4326)
  hawaii <- st_set_geometry(hawaii, hawaii_geom) %>% st_transform(4326)
  mainland <- st_transform(mainland, 4326)

  bind_rows(mainland, alaska, hawaii) %>% st_as_sf()
}

crowding_shifted <- shift_geometry(crowding_clean)
state_geom <- shift_geometry(state_geom)

# 5. World mask
world_box <- st_as_sfc(st_bbox(c(xmin = -180, ymin = -90, xmax = 180, ymax = 90)), crs = 4326)
us_box <- st_as_sfc(st_bbox(c(xmin = -130, ymin = 15, xmax = -60, ymax = 55)), crs = 4326)
mask_polygon <- st_difference(st_make_valid(world_box), st_make_valid(us_box)) %>%
  st_collection_extract("POLYGON") %>%
  st_set_crs(4326)

# 6. Color palette
vals <- crowding_shifted$avg_ppr
vals <- vals[is.finite(vals)]
breaks <- pretty(vals)
colors <- colorRampPalette(brewer.pal(9, "Oranges"))(length(breaks) - 1)
pal <- colorBin(colors, domain = vals, bins = breaks)

# 7. Build leaflet map
crowding_map <- leaflet(options = leafletOptions(
  minZoom = 4, maxZoom = 4,
  zoomControl = FALSE, dragging = FALSE, scrollWheelZoom = FALSE, doubleClickZoom = FALSE
)) %>%
  addTiles(urlTemplate = "") %>%
  addRectangles(lng1 = -180, lat1 = -90, lng2 = 180, lat2 = 90,
                fillColor = "white", fillOpacity = 1, stroke = FALSE) %>%
  addPolygons(data = mask_polygon, fillColor = "white", color = "white", weight = 0, fillOpacity = 1) %>%
  addPolygons(
    data = crowding_shifted,
    fillColor = ~pal(avg_ppr),
    color = "white", weight = 0.3, fillOpacity = 0.9,
    label = ~paste0(NAME, ": ", round(avg_ppr, 2), " people per room"),
    highlightOptions = highlightOptions(weight = 1, color = "black", bringToFront = TRUE)
  ) %>%
  addPolygons(
    data = state_geom,
    fillOpacity = 0, color = "black", weight = 1,
    layerId = ~link,
    highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
  ) %>%
  addLegend(
    position = "topright", colors = colors,
    labels = round(breaks[-length(breaks)], 2),
    title = "Avg. Persons per Room", opacity = 1
  ) %>%
  setView(lng = -98.5, lat = 39.8, zoom = 8)

# 8. Add click-to-link behavior
crowding_map <- onRender(crowding_map, "
  function(el, x) {
    var map = this;
    map.eachLayer(function(layer) {
      if (layer.options && layer.options.layerId) {
        layer.on('click', function(e) {
          window.top.location.href = layer.options.layerId;
        });
      }
    });
  }
")

# 9. Save
saveWidget(
  widget = crowding_map,
  file = '/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/crowding-map.html',
  selfcontained = FALSE
)


# state maps 

walk(unique(crowding_clean$state_fips), function(fips) {
  state_data <- crowding_clean %>%
    filter(state_fips == fips)

  vals <- state_data$pct_no_internet
  vals <- vals[is.finite(vals) & vals > 0]

  if (length(unique(vals)) < 2) return(NULL)

  breaks <- pretty(vals) 
  colors <- colorRampPalette(brewer.pal(9, "YlOrRd"))(length(breaks) - 1)
  pal <- colorBin(palette = colors, domain = vals, bins = breaks)

  leaflet_map <- leaflet(state_data, options = leafletOptions(minZoom = 5, maxZoom = 8)) %>%
    addProviderTiles("CartoDB.PositronNoLabels") %>%
    addPolygons(
      fillColor = ~pal(pct_no_internet),
      fillOpacity = 0.9,
      color = "white",
      weight = 1,
      label = ~paste0(NAME, ": ", round(pct_no_internet * 100, 1), "%"),
      highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
    ) %>%
    addLegend(
      position = "topright",
      colors = colors,
      labels = paste0(round(breaks[-length(breaks)] * 100, 1), "%"),
      title = "Households Without Internet (2023)",
      opacity = 1
    )

  saveWidget(
    widget = leaflet_map,
    file = paste0(
      "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/internet-maps/",
      fips, ".html"
    ),
    selfcontained = FALSE
  )
})


```

# movers 
```{r}


# 1. Download recent mover data
movers_data <- get_acs(
  geography = "county",
  variables = c(
    total = "B07003_001",
    moved_recent = "B07003_017"
  ),
  year = 2023,
  survey = "acs5",
  geometry = TRUE
)

# 2. Prepare data and compute % recent movers
movers_clean <- movers_data %>%
  select(GEOID, NAME, variable, estimate, geometry) %>%
  pivot_wider(names_from = variable, values_from = estimate) %>%
  mutate(
    pct_moved = moved_recent / total,
    state_fips = substr(GEOID, 1, 2)
  )

# 3. Shift AK & HI
shift_geometry <- function(sf_obj) {
  alaska <- sf_obj %>% filter(state_fips == "02") %>% st_transform(2163)
  hawaii <- sf_obj %>% filter(state_fips == "15") %>% st_transform(2163)
  mainland <- sf_obj %>% filter(!state_fips %in% c("02", "15")) %>% st_transform(2163)

  alaska_geom <- st_geometry(alaska) * 0.3 + c(-380000, -3000000)
  hawaii_geom <- st_geometry(hawaii) * 1.2 + c(4500000, -900000)

  st_crs(alaska_geom) <- 2163
  st_crs(hawaii_geom) <- 2163

  alaska <- st_set_geometry(alaska, alaska_geom) %>% st_transform(4326)
  hawaii <- st_set_geometry(hawaii, hawaii_geom) %>% st_transform(4326)
  mainland <- st_transform(mainland, 4326)

  bind_rows(mainland, alaska, hawaii) %>% st_as_sf()
}

movers_shifted <- shift_geometry(movers_clean)

# 4. Create state-level clickable outlines
state_geom <- states(cb = TRUE, year = 2023) %>%
  filter(!STATEFP %in% c("72", "78")) %>%
  select(state_fips = STATEFP, geometry) %>%
  mutate(link = paste0("movers-pages/", state_fips, ".html")) %>%
  shift_geometry()

# 5. Mask outside US
world_box <- st_as_sfc(st_bbox(c(xmin = -180, ymin = -90, xmax = 180, ymax = 90)), crs = 4326)
us_box <- st_as_sfc(st_bbox(c(xmin = -130, ymin = 15, xmax = -60, ymax = 55)), crs = 4326)
mask_polygon <- st_difference(st_make_valid(world_box), st_make_valid(us_box)) %>%
  st_collection_extract("POLYGON") %>%
  st_set_crs(4326)

# 6. Color scale
vals <- movers_shifted$pct_moved
vals <- vals[is.finite(vals)]
breaks <- pretty(vals)
colors <- colorRampPalette(brewer.pal(9, "YlGnBu"))(length(breaks) - 1)
pal <- colorBin(colors, domain = vals, bins = breaks)

# 7. Build leaflet map
movers_map <- leaflet(options = leafletOptions(
  minZoom = 4, maxZoom = 4,
  zoomControl = FALSE, dragging = FALSE,
  scrollWheelZoom = FALSE, doubleClickZoom = FALSE
)) %>%
  addTiles(urlTemplate = "") %>%
  addRectangles(lng1 = -180, lat1 = -90, lng2 = 180, lat2 = 90,
                fillColor = "white", fillOpacity = 1, stroke = FALSE) %>%
  addPolygons(data = mask_polygon, fillColor = "white", color = "white", weight = 0, fillOpacity = 1) %>%
  addPolygons(
    data = movers_shifted,
    fillColor = ~pal(pct_moved),
    fillOpacity = 0.9, color = "white", weight = 0.3,
    label = ~paste0(NAME, ": ", round(pct_moved * 100, 1), "% moved in past year"),
    highlightOptions = highlightOptions(weight = 1, color = "black", bringToFront = TRUE)
  ) %>%
  addPolygons(
    data = state_geom,
    fillOpacity = 0, color = "black", weight = 1,
    layerId = ~link,
    highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
  ) %>%
  addLegend(
    position = "topright", colors = colors,
    labels = paste0(round(breaks[-length(breaks)] * 100, 1), "%"),
    title = "Moved In Last Year (2023)", opacity = 1
  ) %>%
  setView(lng = -98.5, lat = 39.8, zoom = 8)

# 8. Make states clickable
movers_map <- onRender(movers_map, "
  function(el, x) {
    var map = this;
    map.eachLayer(function(layer) {
      if (layer.options && layer.options.layerId) {
        layer.on('click', function(e) {
          window.top.location.href = layer.options.layerId;
        });
      }
    });
  }
")

# 9. Save
saveWidget(
  widget = movers_map,
  file = "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/movers-map.html",
  selfcontained = FALSE
)



```


# vehicle access 
```{r}


vehicle_data <- get_acs(
  geography = "county",
  variables = c(
    total = "B25044_001",
    no_vehicle = "B25044_003"
  ),
  year = 2023,
  survey = "acs5",
  geometry = TRUE
)

vehicle_clean <- vehicle_data %>%
  select(GEOID, NAME, variable, estimate, geometry) %>%
  pivot_wider(names_from = variable, values_from = estimate) %>%
  mutate(
    pct_no_vehicle = no_vehicle / total,
    state_fips = substr(GEOID, 1, 2)
  )

# 2. Shift Alaska and Hawaii
shift_geometry <- function(sf_obj) {
  alaska <- sf_obj %>% filter(state_fips == "02") %>% st_transform(2163)
  hawaii <- sf_obj %>% filter(state_fips == "15") %>% st_transform(2163)
  mainland <- sf_obj %>% filter(!state_fips %in% c("02", "15")) %>% st_transform(2163)

  alaska_geom <- st_geometry(alaska) * 0.3 + c(-380000, -3000000)
  hawaii_geom <- st_geometry(hawaii) * 1.2 + c(4500000, -900000)

  st_crs(alaska_geom) <- 2163
  st_crs(hawaii_geom) <- 2163

  alaska <- st_set_geometry(alaska, alaska_geom) %>% st_transform(4326)
  hawaii <- st_set_geometry(hawaii, hawaii_geom) %>% st_transform(4326)
  mainland <- st_transform(mainland, 4326)

  bind_rows(mainland, alaska, hawaii) %>% st_as_sf()
}

vehicle_shifted <- shift_geometry(vehicle_clean)

# 3. State outlines with clickable links
state_geom <- states(cb = TRUE, year = 2023) %>%
  filter(!STATEFP %in% c("72", "78")) %>%
  select(state_fips = STATEFP, geometry) %>%
  mutate(link = paste0("vehicle-pages/", state_fips, ".html")) %>%
  shift_geometry()

# 4. White mask background
world_box <- st_as_sfc(st_bbox(c(xmin = -180, ymin = -90, xmax = 180, ymax = 90)), crs = 4326)
us_box <- st_as_sfc(st_bbox(c(xmin = -130, ymin = 15, xmax = -60, ymax = 55)), crs = 4326)

mask_polygon <- st_difference(st_make_valid(world_box), st_make_valid(us_box)) %>%
  st_collection_extract("POLYGON") %>%
  st_set_crs(4326)

# 5. Color scale setup
vals <- vehicle_shifted$pct_no_vehicle
vals <- vals[is.finite(vals)]
breaks <- pretty(vals)
colors <- colorRampPalette(brewer.pal(9, "Reds"))(length(breaks) - 1)
pal <- colorBin(colors, domain = vals, bins = breaks)

# 6. Build the leaflet map
vehicle_map <- leaflet(options = leafletOptions(
  minZoom = 4, maxZoom = 4,
  zoomControl = FALSE, dragging = FALSE,
  scrollWheelZoom = FALSE, doubleClickZoom = FALSE
)) %>%
  addTiles(urlTemplate = "") %>%
  addRectangles(lng1 = -180, lat1 = -90, lng2 = 180, lat2 = 90,
                fillColor = "white", fillOpacity = 1, stroke = FALSE) %>%
  addPolygons(data = mask_polygon, fillColor = "white", color = "white", weight = 0, fillOpacity = 1) %>%
  addPolygons(
    data = vehicle_shifted,
    fillColor = ~pal(pct_no_vehicle),
    color = "white", weight = 0.3, fillOpacity = 0.9,
    label = ~paste0(NAME, ": ", round(pct_no_vehicle * 100, 1), "%"),
    highlightOptions = highlightOptions(weight = 1, color = "black", bringToFront = TRUE)
  ) %>%
  addPolygons(
    data = state_geom,
    fillOpacity = 0, color = "black", weight = 1,
    layerId = ~link,
    highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
  ) %>%
  addLegend(
    position = "topright", colors = colors,
    labels = paste0(round(breaks[-length(breaks)] * 100, 1), "%"),
    title = "Households Without Vehicle (2023)", opacity = 1
  ) %>%
  setView(lng = -98.5, lat = 39.8, zoom = 8)

# 7. Add clickable state redirect
vehicle_map <- onRender(vehicle_map, "
  function(el, x) {
    var map = this;
    map.eachLayer(function(layer) {
      if (layer.options && layer.options.layerId) {
        layer.on('click', function(e) {
          window.top.location.href = layer.options.layerId;
        });
      }
    });
  }
")

# 8. Save to file
saveWidget(
  widget = vehicle_map,
  file = '/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/vehicle-map.html',
  selfcontained = FALSE
)

```


# dive deeper 
```{r}




# USA MAP 

library(tigris)
library(sf)
library(dplyr)
library(leaflet)
library(htmlwidgets)
library(glue)

options(tigris_use_cache = TRUE)

# -------------------- SHIFT FUNCTION --------------------
shift_geometry <- function(sf_obj) {
  alaska <- sf_obj %>% filter(state_fips == "02") %>% st_transform(2163)
  hawaii <- sf_obj %>% filter(state_fips == "15") %>% st_transform(2163)
  mainland <- sf_obj %>% filter(!state_fips %in% c("02", "15")) %>% st_transform(4326)

  alaska_geom <- st_geometry(alaska) * 0.3 + c(-380000, -3000000)
  hawaii_geom <- st_geometry(hawaii) * 1.2 + c(4500000, -900000)

  st_crs(alaska_geom) <- 2163
  st_crs(hawaii_geom) <- 2163

  alaska <- st_set_geometry(alaska, alaska_geom) %>% st_transform(4326)
  hawaii <- st_set_geometry(hawaii, hawaii_geom) %>% st_transform(4326)

  bind_rows(mainland, alaska, hawaii) %>% st_as_sf()
}

# -------------------- STEP 1: Load & Shift State Geometries --------------------
state_geom <- states(cb = TRUE, year = 2023) %>%
  filter(!STATEFP %in% c("72", "78")) %>%
  select(state_fips = STATEFP, STUSPS, NAME, geometry) %>%
  mutate(link = glue("school-district-widgets/districts_{tolower(STUSPS)}.html"))

state_geom <- shift_geometry(state_geom)

# -------------------- STEP 2: Build White Background Mask --------------------
mask_box <- st_as_sfc(st_bbox(c(xmin = -180, ymin = -90, xmax = 180, ymax = 90)), crs = 4326)
us_box <- st_as_sfc(st_bbox(c(xmin = -130, ymin = 15, xmax = -60, ymax = 55)), crs = 4326)

mask_diff <- st_difference(mask_box, us_box)
mask_polygon <- st_make_valid(mask_diff)
st_crs(mask_polygon) <- st_crs(us_box)

# -------------------- STEP 3: Build Leaflet Map --------------------
explore_map <- leaflet(options = leafletOptions(
  minZoom = 4, maxZoom = 4,
  zoomControl = FALSE, dragging = FALSE,
  scrollWheelZoom = FALSE, doubleClickZoom = FALSE,
  boxZoom = FALSE, touchZoom = FALSE
)) %>%
  # Pure white background (covers the world)
  addRectangles(-180, -90, 180, 90, fillColor = "white", fillOpacity = 1, stroke = FALSE) %>%

  # Mask everything outside the U.S. box
  addPolygons(data = mask_polygon, fillColor = "white", color = "white", weight = 0, fillOpacity = 1) %>%

  # Add clickable state polygons
  addPolygons(
    data = state_geom,
    fillColor = "lightgray",
    fillOpacity = 0.65,
    color = "#333", weight = 1.2,
    label = ~NAME,
    layerId = ~link,
    highlightOptions = highlightOptions(weight = 2.5, color = "#000", bringToFront = TRUE)
  ) %>%
  setView(lng = -98.5, lat = 39.8, zoom = 4)

# -------------------- STEP 4: Add Click-to-Link JS Behavior --------------------
explore_map <- onRender(explore_map, "
  function(el, x) {
    var map = this;
    map.eachLayer(function(layer) {
      if (layer.options && layer.options.layerId) {
        layer.on('click', function(e) {
          window.location.href = layer.options.layerId;
        });
      }
    });
  }
")

library(htmltools)

explore_map <- tagList(
  tags$h2("Explore by School District", style = "text-align: center; font-family: sans-serif; margin-top: 20px;"),
  explore_map
)

# -------------------- STEP 5: Save HTML --------------------
saveWidget(
  widget = explore_map,
  file = '/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/explore/explore-usa.html',
  selfcontained = FALSE
)


# district data 
library(tidycensus)
library(tidyverse)
library(jsonlite)
library(stringr)

# Correct set of ACS variables
vars <- c(
  population = "B01003_001",
  median_age = "B01002_001",
  income = "B19301_001",
  white = "B02001_002",
  black = "B02001_003",
  asian = "B02001_005",
  hispanic = "B03003_003",
  poverty = "B17001_002",
  poverty_total = "B17001_001",
  pct_bachelors_higher = "S1501_C02_015",  # <- precomputed
  median_rent = "B25064_001",
  median_home_value = "B25077_001"
)

# Get state list
state_list <- unique(fips_codes$state)[!fips_codes$state %in% c("72", "78")]

# Output dir
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/explore/school-district-jsons"
dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)

walk(state_list, function(state_abbr) {
  message("Processing: ", state_abbr)

  data <- tryCatch({
    get_acs(
      geography = "school district (unified)",
      state = state_abbr,
      variables = vars,
      year = 2023,
      survey = "acs5",
      output = "wide",
      geometry = FALSE
    )
  }, error = function(e) {
    message("Skipping: ", state_abbr)
    return(NULL)
  })

  if (is.null(data)) return(NULL)

  cleaned <- data %>%
    transmute(
      GEOID,
      NAME = str_remove(NAME, " School District.*"),
      population = populationE,
      median_age = median_ageE,
      income = incomeE,
      median_rent = median_rentE,
      median_home_value = median_home_valueE,
      pct_white = 100 * whiteE / populationE,
      pct_black = 100 * blackE / populationE,
      pct_asian = 100 * asianE / populationE,
      pct_hispanic = 100 * hispanicE / populationE,
      pct_poverty = 100 * povertyE / poverty_totalE,
      pct_bachelors_higher = pct_bachelors_higherE
    )

  # Save as JSON
  write_json(
    cleaned,
    path = file.path(output_dir, paste0("districts_", tolower(state_abbr), ".json")),
    pretty = TRUE,
    na = "null",
    auto_unbox = TRUE
  )
})

# WIDGETS 


json_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/explore/school-district-jsons"
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/explore/school-district-widgets"
dir_create(output_dir)

# List JSON files
json_files <- dir_ls(json_dir, regexp = "districts_.*\\.json$")

walk(json_files, function(file_path) {
  state_abbr <- str_match(basename(file_path), "districts_(.*)\\.json")[,2]

  data <- fromJSON(file_path) %>%
    transmute(
      District = NAME,
      Population = population,
      `Median Age` = median_age,
      `Per Capita Income` = income,
      `Median Rent` = median_rent,
      `Median Home Value` = median_home_value,
      `% White` = round(pct_white, 1),
      `% Black` = round(pct_black, 1),
      `% Asian` = round(pct_asian, 1),
      `% Hispanic` = round(pct_hispanic, 1),
      `% in Poverty` = round(pct_poverty, 1),
      `% with College Education` = round(pct_bachelors_higher, 1)
    )

  widget <- datatable(
    data,
    rownames = FALSE,
    filter = "top",
    options = list(
      pageLength = 15,
      scrollX = TRUE,
      order = list(list(1, "desc")),
      columnDefs = list(list(className = "dt-center", targets = "_all"))
    )
  )

  saveWidget(
    widget,
    file = file.path(output_dir, glue("districts_{state_abbr}.html")),
    selfcontained = FALSE
  )
})





```


# industry earnings map 
```{r}
library(tidycensus)
library(dplyr)
library(tidyr)
library(stringr)
library(sf)
library(leaflet)
library(RColorBrewer)
library(htmlwidgets)


acs_vars <- load_variables(2023, "acs1", cache = TRUE)
acs_vars %>% filter(str_detect(name, "S2414"))

# Pull the data for a specific geography (e.g., states)
industry_data <- get_acs(
  geography = "county",
  table = "S2414",
  year = 2023,
  survey = "acs5",
  cache_table = TRUE,
  geometry = TRUE
)

# -------------------- STEP 2: CLEAN AND TRANSFORM --------------------

industry_lookup <- tibble::tibble(
  group = c(
    "Agriculture, forestry, fishing and hunting, and mining",
    "Construction",
    "Manufacturing",
    "Wholesale trade",
    "Retail trade",
    "Transportation and warehousing, and utilities",
    "Information",
    "Finance and insurance, and real estate and rental and leasing",
    "Professional, scientific, and management, and administrative and waste management services",
    "Educational services, and health care and social assistance",
    "Arts, entertainment, and recreation, and accommodation and food services",
    "Other services, except public administration",
    "Public administration"
  ),
  variables = list(
    c("S2414_C01_002"),  # Agriculture
    c("S2414_C01_005"),
    c("S2414_C01_006"),
    c("S2414_C01_007"),
    c("S2414_C01_008"),
    c("S2414_C01_009"),
    c("S2414_C01_012"),
    c("S2414_C01_013"),
    c("S2414_C01_016"),
    c("S2414_C01_020"),
    c("S2414_C01_023"),
    c("S2414_C01_026"),
    c("S2414_C01_027")
  )
)


industry_lookup_long <- industry_lookup %>%
  tidyr::unnest(variables) %>%
  rename(variable = variables, industry = group)

# -------------------- STEP 3: Recode & Pivot to Wide Format --------------------

industry_wide <- industry_data %>%
  left_join(industry_lookup_long, by = "variable") %>%
  filter(!is.na(industry)) %>%
  group_by(GEOID, NAME, industry) %>%
  summarize(estimate = sum(estimate, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = industry, values_from = estimate) %>%
  mutate(
    total = rowSums(across(where(is.numeric)), na.rm = TRUE),
    state_fips = str_sub(GEOID, 1, 2)
  )

industry_names <- intersect(colnames(industry_wide), industry_lookup$group)

# -------------------- STEP 4: Identify Most Common Industry --------------------

top_industry_data <- industry_wide %>%
  rowwise() %>%
  mutate(
    max_value = max(c_across(all_of(industry_names)), na.rm = TRUE),
    max_industry = industry_names[which.max(c_across(all_of(industry_names)))],
    percent = ifelse(total > 0, 100 * max_value / total, NA_real_)
  ) %>%
  ungroup()

geo_data <- industry_data %>%
  select(GEOID, geometry) %>%
  group_by(GEOID) %>%
  summarize(geometry = first(geometry), .groups = "drop")  # fast + safe

## here


# -------------------- STEP 3: STATE GEOMETRY + SHIFT --------------------
state_geom <- states(cb = TRUE, year = 2023) %>%
  filter(!STATEFP %in% c("72", "78")) %>%
  select(state_fips = STATEFP, geometry) %>%
  mutate(link = paste0("industry-pages/", state_fips, ".html"))

shift_geometry <- function(sf_obj) {
  alaska <- sf_obj %>% filter(state_fips == "02") %>% st_transform(2163)
  hawaii <- sf_obj %>% filter(state_fips == "15") %>% st_transform(2163)
  mainland <- sf_obj %>% filter(!state_fips %in% c("02", "15")) %>% st_transform(4326)
  alaska_geom <- st_geometry(alaska) * 0.3 + c(-380000, -3000000)
  hawaii_geom <- st_geometry(hawaii) * 1.2 + c(4500000, -900000)
  st_crs(alaska_geom) <- 2163; st_crs(hawaii_geom) <- 2163
  alaska <- st_set_geometry(alaska, alaska_geom) %>% st_transform(4326)
  hawaii <- st_set_geometry(hawaii, hawaii_geom) %>% st_transform(4326)
  bind_rows(mainland, alaska, hawaii) %>% st_as_sf()
}

state_geom <- shift_geometry(state_geom)
industry_shifted <- shift_geometry(top_industry_data)

# -------------------- STEP 4: WHITE MASK --------------------
world_box <- st_as_sfc(st_bbox(c(xmin = -180, ymin = -90, xmax = 180, ymax = 90)), crs = 4326)
us_box <- st_as_sfc(st_bbox(c(xmin = -130, ymin = 15, xmax = -60, ymax = 55)), crs = 4326)
mask_diff <- st_difference(st_make_valid(world_box), st_make_valid(us_box))
mask_polygon <- st_collection_extract(mask_diff, "POLYGON") %>% st_make_valid()

# -------------------- STEP 5: COLOR PALETTE --------------------
# Manual industry color definitions (based on CensusScope)

set1_colors <- RColorBrewer::brewer.pal(9, "Set1")

dark2_colors <- setdiff(RColorBrewer::brewer.pal(8, "Dark2"), "#E7298A")
dark2_colors <- setdiff(dark2_colors, "#666666")

# Combine and take the first 13 distinct colors
combined_colors <- c(dark2_colors, set1_colors)[1:13]
combined_colors[c(1, 12)] <- combined_colors[c(12, 1)]
# Match with industry labels
filtered_levels <- industry_lookup$group %>% na.omit() %>% as.character() %>% sort()

filtered_colors <- setNames(combined_colors, filtered_levels)

# Create palette


# Step 3: Set max_industry as factor with correct levels
industry_shifted$max_industry <- factor(industry_shifted$max_industry, levels = filtered_levels)

# Step 4: Create leaflet color function
pal <- colorFactor(palette = filtered_colors, domain = filtered_levels)


# -------------------- STEP 6: LEAFLET MAP --------------------
industry_map <- leaflet(options = leafletOptions(
  minZoom = 4, maxZoom = 4,
  zoomControl = FALSE,
  dragging = FALSE,
  scrollWheelZoom = FALSE,
  doubleClickZoom = FALSE
)) %>%
  addTiles(urlTemplate = "") %>%
  addRectangles(-180, -90, 180, 90, fillColor = "white", fillOpacity = 1, stroke = FALSE) %>%
  addPolygons(data = mask_polygon, fillColor = "white", color = "white", weight = 0, fillOpacity = 1) %>%
  addPolygons(
    data = industry_shifted,
    fillColor = ~pal(max_industry),
    color = "white", weight = 0.3, fillOpacity = 0.9,
    label = ~paste0(NAME, ": ", max_industry, " (", round(percent, 1), "%)"),
    highlightOptions = highlightOptions(weight = 1, color = "black", bringToFront = TRUE)
  ) %>%
  addPolygons(
    data = state_geom,
    fillOpacity = 0,
    color = "black", weight = 1,
    layerId = ~link,
    highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
  ) %>%
  addLegend(
  position = "topright",
  colors = unname(filtered_colors),
  labels = names(filtered_colors),
  title = "Most Common Industry",
  opacity = 1
) %>%
  setView(lng = -98.5, lat = 39.8, zoom = 8)

# -------------------- STEP 7: CLICK BEHAVIOR --------------------
industry_map <- htmlwidgets::onRender(industry_map, "
  function(el, x) {
    var map = this;
    var hash = window.location.hash;
    map.eachLayer(function(layer) {
      if (layer.options && layer.options.layerId) {
        layer.on('click', function(e) {
          window.top.location.href = layer.options.layerId + hash;
        });
      }
    });
  }
")

# -------------------- STEP 8: SAVE --------------------
saveWidget(
  widget = industry_map,
  file = '/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/industryearnings.html',
  selfcontained = FALSE
)

```


# industry trend charts 
```{r}

library(dplyr)
library(glue)
library(htmltools)
library(jsonlite)
library(dplyr)
library(stringr)
library(tidyr)
library(jsonlite)
library(htmltools)
library(glue)

set1_colors <- RColorBrewer::brewer.pal(9, "Set1")

dark2_colors <- setdiff(RColorBrewer::brewer.pal(8, "Dark2"), "#E7298A")
dark2_colors <- setdiff(dark2_colors, "#666666")

# Combine and take the first 13 distinct colors
combined_colors <- c(dark2_colors, set1_colors)[1:13]
combined_colors[c(1, 12)] <- combined_colors[c(12, 1)]
# Match with industry labels

filtered_colors <- setNames(combined_colors, filtered_levels)

# Create palette


# Step 3: Set max_industry as factor with correct levels

# --- Step 2: Prepare data ---
# --- Step 2: Prepare data ---
df <- top_industry_data %>%
  st_drop_geometry() %>%
  mutate(
    county = str_remove(NAME, ",.*"),
    state_fips = str_sub(GEOID, 1, 2)
  )

industry_cols <- df %>%
  select(-GEOID, -NAME, -county, -state_fips) %>%
  select(where(is.numeric)) %>%
  names()

df_long <- df %>%
  pivot_longer(cols = all_of(industry_cols), names_to = "industry", values_to = "earnings")

valid_inds <- names(filtered_colors)

# --- LOOP ---
for (fips in unique(df_long$state_fips)) {
  state_data <- df_long %>% filter(state_fips == fips)
  counties <- unique(state_data$county)
  bar_data <- list()

  # STATEWIDE
  statewide_medians <- state_data %>%
    filter(industry %in% valid_inds) %>%
    group_by(industry) %>%
    summarize(earnings = median(earnings, na.rm = TRUE), .groups = "drop")

  bar_data[["Statewide"]] <- as.list(setNames(
    round(statewide_medians$earnings),  # no decimals
    statewide_medians$industry
  ))

  # COUNTIES
  for (cty in counties) {
    cty_medians <- state_data %>%
      filter(county == cty, industry %in% valid_inds) %>%
      group_by(industry) %>%
      summarize(earnings = median(earnings, na.rm = TRUE), .groups = "drop")

    bar_data[[cty]] <- as.list(setNames(
      round(cty_medians$earnings),
      cty_medians$industry
    ))
  }

  bar_json <- toJSON(bar_data, auto_unbox = TRUE, pretty = FALSE)

  colors_js <- paste0(
    "const colors = {\n",
    paste(sprintf("  '%s': '%s'", names(filtered_colors), filtered_colors), collapse = ",\n"),
    "\n};"
  )

  html_page <- htmltools::HTML(glue::glue('
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Median Earnings by Industry – {fips}</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {{
      margin: 0;
      font-family: sans-serif;
      background: white;
    }}
    .layout {{
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1.5rem;
    }}
    label {{
      font-weight: bold;
      margin-bottom: 0.5rem;
    }}
    #countySelect {{
      font-size: 1rem;
      padding: 0.4rem 0.8rem;
      margin-bottom: 1rem;
    }}
    canvas {{
      width: 100%;
    }}
  </style>
</head>
<body>
  <div class="layout">
    <label for="countySelect">Median Earnings by Industry:</label>
    <select id="countySelect"></select>
    <canvas id="barChart"></canvas>
  </div>

  <script>
    const data = {bar_json};
    {colors_js}

    const ctx = document.getElementById("barChart").getContext("2d");
    let chart;

    function renderChart(county) {{
      const values = data[county];
      const labels = Object.keys(values);
      const earnings = Object.values(values);

      if (chart) chart.destroy();

      chart = new Chart(ctx, {{
        type: "bar",
        data: {{
          labels: labels,
          datasets: [{{
            label: "Median Earnings ($)",
            data: earnings,
            backgroundColor: labels.map(label => colors[label] || "#ccc")
          }}]
        }},
        options: {{
          responsive: true,
          maintainAspectRatio: true,
  aspectRatio: 1.5, 
          indexAxis: "x",
          scales: {{
            y: {{
              beginAtZero: true,
              title: {{
                display: true,
                text: "Median Earnings ($)"
              }},
              ticks: {{
                callback: function(value) {{
                  return "$" + value.toLocaleString();
                }}
              }}
            }},
            x: {{
              ticks: {{
                maxRotation: 45,
                minRotation: 20,
                autoSkip: false,
                callback: function(value, index, ticks) {{
                  let label = this.getLabelForValue(value);
                  return label.length > 25 ? label.slice(0, 25) + "…" : label;
                }}
              }}
            }}
          }},
          plugins: {{
            tooltip: {{
              callbacks: {{
                label: function(context) {{
                  return "$" + context.parsed.y.toLocaleString();
                }}
              }}
            }},
            legend: {{
              display: false
            }}
          }}
        }}
      }});
    }}

    const select = document.getElementById("countySelect");
    Object.keys(data).forEach(county => {{
      const option = document.createElement("option");
      option.value = county;
      option.text = county;
      select.appendChild(option);
    }});
    select.value = "Statewide";
    select.addEventListener("change", () => renderChart(select.value));
    renderChart("Statewide");
  </script>
</body>
</html>
'))

  save_html(html_page, file = file.path(
    "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/ind-trend/",
    paste0(fips, ".html")
  ))

  cat("✅ Saved:", fips, "\n")
}







# state maps 
present_levels <- filtered_levels
state_palette <- colorFactor(palette = filtered_colors, domain = present_levels)

# Generate a map for each state
walk(unique(top_industry_data$state_fips), function(fips) {
  state_data <- top_industry_data %>%
    filter(state_fips == fips)

  if (nrow(state_data) == 0 || all(is.na(state_data$max_industry))) return(NULL)

  # Set factor levels explicitly for consistency
  state_data$max_industry <- factor(state_data$max_industry, levels = present_levels)

  leaflet_map <- leaflet(state_data, options = leafletOptions(minZoom = 5, maxZoom = 8)) %>%
    addProviderTiles("CartoDB.PositronNoLabels") %>%
    addPolygons(
      fillColor = ~state_palette(max_industry),
      fillOpacity = 0.9,
      color = "white",
      weight = 1,
      label = ~paste0(NAME, ": ", max_industry),
      highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
    ) %>%
    addLegend(
      position = "topright",
      colors = unname(filtered_colors),
      labels = names(filtered_colors),
      title = "Highest Earning Industry (2023)",
      opacity = 1
    )

  saveWidget(
    widget = leaflet_map,
    file = file.path(
      "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/ind-state-maps/",
      paste0(fips, ".html")
    ),
    selfcontained = FALSE
  )
})

```

# pages
```{r}


state_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/industry-pages"
fips_codes <- sprintf("%02d", 1:56)  # or use unique(state_fips) if you have data

walk(fips_codes, function(fips) {
  file_path <- file.path(state_dir, paste0(fips, ".html"))

  html <- paste0(
'<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>State Page</title>
  <style>
    body {
      margin: 2rem;
      font-family: sans-serif;
    }
    #wrapper {
      display: flex;
      gap: 1rem;
      align-items: flex-start;
    }
    iframe {
      border: none;
    }
    .map-column {
      width: 60%;
    }
    .chart-column {
      width: 40%;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
  </style>
</head>
<body>
<h1>Highest Earning Industry by County - ', fips, '</h1>
  <div id="wrapper">
    <div class="map-column">
      <iframe
        src="../ind-state-maps/', fips, '.html"
        title="County Map"
        style="width: 100%; height: 500px;">
      </iframe>
    </div>

    <div class="chart-column">
      <iframe
        src="../ind-trend/', fips, '.html"
        title="County Table"
        style="width: 100%; height: 600px;">
      </iframe>
    </div>
  </div>
</body>
</html>'
  )

  writeLines(html, file_path)
  cat("✔️ Created:", file_path, "\n")
})


```


# industry COUNTS
```{r}


industry_lookup <- tibble::tibble(
  group = c(
    "Agriculture, forestry, fishing and hunting, and mining",
    "Construction",
    "Manufacturing",
    "Wholesale trade",
    "Retail trade",
    "Transportation and warehousing, and utilities",
    "Information",
    "Finance and insurance, and real estate and rental and leasing",
    "Professional, scientific, and management, and administrative and waste management services",
    "Educational services, and health care and social assistance",
    "Arts, entertainment, and recreation, and accommodation and food services",
    "Other services, except public administration",
    "Public administration"
  ),
  variables = list(
    c("C24030_003", "C24030_030"),  # Agriculture
    c("C24030_006", "C24030_033"), # MALE / FEMALE
    c("C24030_007", "C24030_034"),
    c("C24030_008", "C24030_035"),
    c("C24030_009", "C24030_036"),
    c("C24030_010", "C24030_037"),
    c("C24030_013", "C24030_040"),
    c("C24030_014", "C24030_041"),
    c("C24030_017", "C24030_044"),
    c("C24030_021", "C24030_048"),
    c("C24030_024", "C24030_051"),
    c("C24030_027", "C24030_054"),
    c("C24030_028", "C24030_055")
  )
)




# Pull the data for a specific geography (e.g., states)
industry_data_nums <- get_acs(
  geography = "county",
  table = "C24030",
  year = 2023,
  survey = "acs5",
  cache_table = TRUE,
  geometry = TRUE
)

# -------------------- STEP 2: CLEAN AND TRANSFORM --------------------


industry_lookup_long <- industry_lookup %>%
  tidyr::unnest(variables) %>%
  rename(variable = variables, industry = group)

# -------------------- STEP 3: Recode & Pivot to Wide Format --------------------

industry_wide <- industry_data_nums %>%
  left_join(industry_lookup_long, by = "variable") %>%
  filter(!is.na(industry)) %>%
  group_by(GEOID, NAME, industry) %>%
  summarize(estimate = sum(estimate, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = industry, values_from = estimate) %>%
  mutate(
    total = rowSums(across(where(is.numeric)), na.rm = TRUE),
    state_fips = str_sub(GEOID, 1, 2)
  )

industry_names <- intersect(colnames(industry_wide), industry_lookup$group)

# -------------------- STEP 4: Identify Most Common Industry --------------------

top_industry_data <- industry_wide %>%
  rowwise() %>%
  mutate(
    max_value = max(c_across(all_of(industry_names)), na.rm = TRUE),
    max_industry = industry_names[which.max(c_across(all_of(industry_names)))],
    percent = ifelse(total > 0, 100 * max_value / total, NA_real_)
  ) %>%
  ungroup()

geo_data <- industry_data_nums %>%
  select(GEOID, geometry) %>%
  group_by(GEOID) %>%
  summarize(geometry = first(geometry), .groups = "drop")  # fast + safe

## here


# -------------------- STEP 3: STATE GEOMETRY + SHIFT --------------------
state_geom <- states(cb = TRUE, year = 2023) %>%
  filter(!STATEFP %in% c("72", "78")) %>%
  select(state_fips = STATEFP, geometry) %>%
  mutate(link = paste0("industry-pages-counts/", state_fips, ".html"))

shift_geometry <- function(sf_obj) {
  alaska <- sf_obj %>% filter(state_fips == "02") %>% st_transform(2163)
  hawaii <- sf_obj %>% filter(state_fips == "15") %>% st_transform(2163)
  mainland <- sf_obj %>% filter(!state_fips %in% c("02", "15")) %>% st_transform(4326)
  alaska_geom <- st_geometry(alaska) * 0.3 + c(-380000, -3000000)
  hawaii_geom <- st_geometry(hawaii) * 1.2 + c(4500000, -900000)
  st_crs(alaska_geom) <- 2163; st_crs(hawaii_geom) <- 2163
  alaska <- st_set_geometry(alaska, alaska_geom) %>% st_transform(4326)
  hawaii <- st_set_geometry(hawaii, hawaii_geom) %>% st_transform(4326)
  bind_rows(mainland, alaska, hawaii) %>% st_as_sf()
}

state_geom <- shift_geometry(state_geom)
industry_shifted <- shift_geometry(top_industry_data)

# -------------------- STEP 4: WHITE MASK --------------------
world_box <- st_as_sfc(st_bbox(c(xmin = -180, ymin = -90, xmax = 180, ymax = 90)), crs = 4326)
us_box <- st_as_sfc(st_bbox(c(xmin = -130, ymin = 15, xmax = -60, ymax = 55)), crs = 4326)
mask_diff <- st_difference(st_make_valid(world_box), st_make_valid(us_box))
mask_polygon <- st_collection_extract(mask_diff, "POLYGON") %>% st_make_valid()

# -------------------- STEP 5: COLOR PALETTE --------------------
# Manual industry color definitions (based on CensusScope)

set1_colors <- RColorBrewer::brewer.pal(9, "Set1")

dark2_colors <- setdiff(RColorBrewer::brewer.pal(8, "Dark2"), "#E7298A")
dark2_colors <- setdiff(dark2_colors, "#666666")

# Combine and take the first 13 distinct colors
combined_colors <- c(dark2_colors, set1_colors)[1:13]
combined_colors[c(1, 12)] <- combined_colors[c(12, 1)]
# Match with industry labels
filtered_levels <- industry_lookup$group %>% na.omit() %>% as.character() %>% sort()

filtered_colors <- setNames(combined_colors, filtered_levels)

# Create palette


# Step 3: Set max_industry as factor with correct levels
industry_shifted$max_industry <- factor(industry_shifted$max_industry, levels = filtered_levels)

# Step 4: Create leaflet color function
pal <- colorFactor(palette = filtered_colors, domain = filtered_levels)

# -------------------- STEP 6: LEAFLET MAP --------------------
industry_map <- leaflet(options = leafletOptions(
  minZoom = 4, maxZoom = 4,
  zoomControl = FALSE,
  dragging = FALSE,
  scrollWheelZoom = FALSE,
  doubleClickZoom = FALSE
)) %>%
  addTiles(urlTemplate = "") %>%
  addRectangles(-180, -90, 180, 90, fillColor = "white", fillOpacity = 1, stroke = FALSE) %>%
  addPolygons(data = mask_polygon, fillColor = "white", color = "white", weight = 0, fillOpacity = 1) %>%
  addPolygons(
    data = industry_shifted,
    fillColor = ~pal(max_industry),
    color = "white", weight = 0.3, fillOpacity = 0.9,
    label = ~paste0(NAME, ": ", max_industry, " (", round(percent, 1), "%)"),
    highlightOptions = highlightOptions(weight = 1, color = "black", bringToFront = TRUE)
  ) %>%
  addPolygons(
    data = state_geom,
    fillOpacity = 0,
    color = "black", weight = 1,
    layerId = ~link,
    highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
  ) %>%
  addLegend(
  position = "topright",
  colors = unname(filtered_colors),
  labels = names(filtered_colors),
  title = "Most Common Industry",
  opacity = 1
) %>%
  setView(lng = -98.5, lat = 39.8, zoom = 8)

# -------------------- STEP 7: CLICK BEHAVIOR --------------------
industry_map <- htmlwidgets::onRender(industry_map, "
  function(el, x) {
    var map = this;
    var hash = window.location.hash;
    map.eachLayer(function(layer) {
      if (layer.options && layer.options.layerId) {
        layer.on('click', function(e) {
          window.top.location.href = layer.options.layerId + hash;
        });
      }
    });
  }
")

# -------------------- STEP 8: SAVE --------------------
saveWidget(
  widget = industry_map,
  file = '/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/industry.html',
  selfcontained = FALSE
)





# state maps counts 




# state maps 
present_levels <- filtered_levels
state_palette <- colorFactor(palette = filtered_colors, domain = present_levels)

# Generate a map for each state
walk(unique(top_industry_data$state_fips), function(fips) {
  state_data <- top_industry_data %>%
    filter(state_fips == fips)

  if (nrow(state_data) == 0 || all(is.na(state_data$max_industry))) return(NULL)

  # Set factor levels explicitly for consistency
  state_data$max_industry <- factor(state_data$max_industry, levels = present_levels)

  leaflet_map <- leaflet(state_data, options = leafletOptions(minZoom = 5, maxZoom = 8)) %>%
    addProviderTiles("CartoDB.PositronNoLabels") %>%
    addPolygons(
      fillColor = ~state_palette(max_industry),
      fillOpacity = 0.9,
      color = "white",
      weight = 1,
      label = ~paste0(NAME, ": ", max_industry),
      highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
    ) %>%
    addLegend(
      position = "topright",
      colors = unname(filtered_colors),
      labels = names(filtered_colors),
      title = "Most Common Industry (2023)",
      opacity = 1
    )

  saveWidget(
    widget = leaflet_map,
    file = file.path(
      "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/ind-state-maps-counts/",
      paste0(fips, ".html")
    ),
    selfcontained = FALSE
  )
})







library(readr)
library(dplyr)
library(tidyr)

# Step 1: Read in your NHGIS CSV
library(readr)
df <- read_csv("nhgis0001_ds151_2000_county.csv")  # Or full path if needed

# Step 2: Define industry variable codes (male + female)
industry_lookup <- tibble::tibble(
  industry = c(
    "Agriculture, forestry, fishing, mining",
    "Construction",
    "Manufacturing",
    "Wholesale trade",
    "Retail trade",
    "Transportation, warehousing, utilities",
    "Information",
    "Finance, insurance, real estate",
    "Professional and management services",
    "Education and health services",
    "Arts, entertainment, food services",
    "Other services (except public admin)",
    "Public administration"
  ),
  male_vars = paste0("GMH", sprintf("%03d", 1:13)),
  female_vars = paste0("GMH", sprintf("%03d", 14:26))
)

# Step 3: For each industry, sum male + female
for (i in seq_len(nrow(industry_lookup))) {
  male_var <- industry_lookup$male_vars[i]
  female_var <- industry_lookup$female_vars[i]
  new_col <- paste0("ind_", i)
  df[[new_col]] <- df[[male_var]] + df[[female_var]]
  industry_lookup$total_col[i] <- new_col
}

# Step 4: Identify most common industry per county
industry_cols <- industry_lookup$total_col

df_top <- df %>%
  select(GISJOIN, NAME, all_of(industry_cols)) %>%
  rowwise() %>%
  mutate(
    top_industry_index = which.max(c_across(all_of(industry_cols))),
    top_industry = industry_lookup$industry[top_industry_index]
  ) %>%
  ungroup()

# Result: df_top has most common industry per county

industry_label_map <- c(
  "Agriculture, forestry, fishing, mining" = "Agriculture, forestry, fishing and hunting, and mining",
  "Construction" = "Construction",
  "Manufacturing" = "Manufacturing",
  "Wholesale trade" = "Wholesale trade",
  "Retail trade" = "Retail trade",
  "Transportation, warehousing, utilities" = "Transportation and warehousing, and utilities",
  "Information" = "Information",
  "Finance, insurance, real estate" = "Finance and insurance, and real estate and rental and leasing",
  "Professional and management services" = "Professional, scientific, and management, and administrative and waste management services",
  "Education and health services" = "Educational services, and health care and social assistance",
  "Arts, entertainment, food services" = "Arts, entertainment, and recreation, and accommodation and food services",
  "Other services (except public admin)" = "Other services, except public administration",
  "Public administration" = "Public administration"
)

df_top <- df_top %>%
  mutate(
    max_industry = industry_label_map[top_industry],
    state_fips = substr(GISJOIN, 2, 3),   # characters 2–3 = state FIPS
    county_fips = substr(GISJOIN, 5, 7),  # characters 4–6 = county FIPS
    GEOID = paste0(state_fips, county_fips)
  ) 


# -----

options(tigris_use_cache = TRUE)

# -------------------- STEP 1: GET COUNTY GEOMETRY --------------------

county_geom <- counties(cb = TRUE, year = 2000) %>%
  st_transform(4326) %>%
  mutate(GEOID = paste0(STATE, COUNTYFP))

# -------------------- STEP 2: JOIN WITH TOP INDUSTRY --------------------


top_industry_data <- county_geom %>%
  left_join(df_top %>% select(GEOID, NAME, max_industry), by = "GEOID") %>%
  mutate(state_fips = STATE) %>%
  shift_geometry()

# -------------------- STEP 3: SHIFT GEOMETRY --------------------

shift_geometry <- function(sf_obj) {
  alaska <- sf_obj %>% filter(state_fips == "02") %>% st_transform(2163)
  hawaii <- sf_obj %>% filter(state_fips == "15") %>% st_transform(2163)
  mainland <- sf_obj %>% filter(!state_fips %in% c("02", "15")) %>% st_transform(4326)
  alaska_geom <- st_geometry(alaska) * 0.3 + c(-380000, -3000000)
  hawaii_geom <- st_geometry(hawaii) * 1.2 + c(4500000, -900000)
  st_crs(alaska_geom) <- 2163; st_crs(hawaii_geom) <- 2163
  alaska <- st_set_geometry(alaska, alaska_geom) %>% st_transform(4326)
  hawaii <- st_set_geometry(hawaii, hawaii_geom) %>% st_transform(4326)
  bind_rows(mainland, alaska, hawaii) %>% st_as_sf()
}

industry_shifted <- top_industry_data

# -------------------- STEP 4: STATE BOUNDARIES --------------------

state_geom <- states(cb = TRUE, year = 2000)%>%
filter(!STATE %in% c("72", "78")) %>%
  select(state_fips = STATE, geometry) %>%
  shift_geometry()

# -------------------- STEP 5: WHITE MASK --------------------

world_box <- st_as_sfc(st_bbox(c(xmin = -180, ymin = -90, xmax = 180, ymax = 90)), crs = 4326)
us_box <- st_as_sfc(st_bbox(c(xmin = -130, ymin = 15, xmax = -60, ymax = 55)), crs = 4326)
mask_polygon <- st_difference(st_make_valid(world_box), st_make_valid(us_box)) %>%
  st_collection_extract("POLYGON") %>%
  st_make_valid()

# --------------- STEP 6: COLOR PALETTE --------------------
# 2. Apply label map to your 2000 `max_industry` values








set1_colors <- RColorBrewer::brewer.pal(9, "Set1")

dark2_colors <- setdiff(RColorBrewer::brewer.pal(8, "Dark2"), "#E7298A")
dark2_colors <- setdiff(dark2_colors, "#666666")

# Combine and take the first 13 distinct colors
combined_colors <- c(dark2_colors, set1_colors)[1:13]
combined_colors[c(1, 12)] <- combined_colors[c(12, 1)]
# Match with industry labels


industry_lookup <- tibble::tibble(
  group = c(
    "Agriculture, forestry, fishing and hunting, and mining",
    "Construction",
    "Manufacturing",
    "Wholesale trade",
    "Retail trade",
    "Transportation and warehousing, and utilities",
    "Information",
    "Finance and insurance, and real estate and rental and leasing",
    "Professional, scientific, and management, and administrative and waste management services",
    "Educational services, and health care and social assistance",
    "Arts, entertainment, and recreation, and accommodation and food services",
    "Other services, except public administration",
    "Public administration"
  ),
  variables = list(
    c("C24030_003", "C24030_030"),  # Agriculture
    c("C24030_006", "C24030_033"), # MALE / FEMALE
    c("C24030_007", "C24030_034"),
    c("C24030_008", "C24030_035"),
    c("C24030_009", "C24030_036"),
    c("C24030_010", "C24030_037"),
    c("C24030_013", "C24030_040"),
    c("C24030_014", "C24030_041"),
    c("C24030_017", "C24030_044"),
    c("C24030_021", "C24030_048"),
    c("C24030_024", "C24030_051"),
    c("C24030_027", "C24030_054"),
    c("C24030_028", "C24030_055")
  )
)
filtered_levels <- industry_lookup$group %>% na.omit() %>% as.character() %>% sort()

filtered_colors <- setNames(combined_colors, filtered_levels)

# Create palette



# Step 3: Set max_industry as factor with correct levels
industry_shifted$max_industry <- factor(industry_shifted$max_industry, levels = filtered_levels)

# Step 4: Create leaflet color function
pal <- colorFactor(palette = filtered_colors, domain = filtered_levels)





# -------------------- STEP 7: BUILD MAP --------------------

industry_map <- leaflet(options = leafletOptions(
  minZoom = 4, maxZoom = 4,
  zoomControl = FALSE,
  dragging = FALSE,
  scrollWheelZoom = FALSE,
  doubleClickZoom = FALSE
)) %>%
  addTiles(urlTemplate = "") %>%
  addRectangles(-180, -90, 180, 90, fillColor = "white", fillOpacity = 1, stroke = FALSE) %>%
  addPolygons(data = mask_polygon, fillColor = "white", color = "white", weight = 0, fillOpacity = 1) %>%
  addPolygons(
    data = industry_shifted,
    fillColor = ~pal(max_industry),
    color = "white", weight = 0.3, fillOpacity = 0.9,
    label = ~paste0(": ", max_industry),
    highlightOptions = highlightOptions(weight = 1, color = "black", bringToFront = TRUE)
  ) %>%
  addPolygons(
    data = state_geom,
    fillOpacity = 0, color = "black", weight = 1
  ) %>%
  addLegend(
  pal = pal,
  values = industry_shifted$max_industry,
  title = "Most Common Industry (2000)",
  opacity = 1,
  labFormat = labelFormat()  # optional: format or abbreviate labels
) %>%
  setView(lng = -98.5, lat = 39.8, zoom = 8)


saveWidget(
  widget = industry_map,
  file = "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/industry2000.html",
  selfcontained = FALSE
)





# 2010 data

industry_data_2010 <- get_acs(
  geography = "county",
  table = "C24030",
  year = 2010,
  survey = "acs5",
  geometry = TRUE,
  cache_table = TRUE
)

# Reuse 2023 industry_lookup (already defined with correct C24030 codes)
industry_lookup_long <- industry_lookup %>%
  tidyr::unnest(variables) %>%
  rename(variable = variables, industry = group)

industry_wide_2010 <- industry_data_2010 %>%
  left_join(industry_lookup_long, by = "variable") %>%
  filter(!is.na(industry)) %>%
  group_by(GEOID, NAME, industry) %>%
  summarize(estimate = sum(estimate, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = industry, values_from = estimate) %>%
  mutate(
    total = rowSums(across(where(is.numeric)), na.rm = TRUE),
    state_fips = str_sub(GEOID, 1, 2)
  )

industry_names <- intersect(colnames(industry_wide_2010), industry_lookup$group)

# -------------------- STEP 2: GET GEOMETRY --------------------

# Extract geometry separately (from original data)
geo_data <- industry_wide_2010 %>%
  select(GEOID, geometry)

# -------------------- STEP 3: IDENTIFY MOST COMMON --------------------

top_industry_data <- industry_wide_2010 %>%
  rowwise() %>%
  mutate(
    max_value = max(c_across(all_of(industry_names)), na.rm = TRUE),
    max_industry = industry_names[which.max(c_across(all_of(industry_names)))],
    percent = ifelse(total > 0, 100 * max_value / total, NA_real_)
  ) %>%
  ungroup()


# -------------------- STEP 4: SHIFT GEOMETRY --------------------

shift_geometry <- function(sf_obj) {
  alaska <- sf_obj %>% filter(state_fips == "02") %>% st_transform(2163)
  hawaii <- sf_obj %>% filter(state_fips == "15") %>% st_transform(2163)
  mainland <- sf_obj %>% filter(!state_fips %in% c("02", "15")) %>% st_transform(4326)
  alaska_geom <- st_geometry(alaska) * 0.3 + c(-380000, -3000000)
  hawaii_geom <- st_geometry(hawaii) * 1.2 + c(4500000, -900000)
  st_crs(alaska_geom) <- 2163; st_crs(hawaii_geom) <- 2163
  alaska <- st_set_geometry(alaska, alaska_geom) %>% st_transform(4326)
  hawaii <- st_set_geometry(hawaii, hawaii_geom) %>% st_transform(4326)
  bind_rows(mainland, alaska, hawaii) %>% st_as_sf()
}

industry_shifted <- shift_geometry(top_industry_data)

state_geom <- states(cb = TRUE, year = 2023) %>%
  filter(!STATEFP %in% c("72", "78")) %>%
  select(state_fips = STATEFP, geometry) %>%
  mutate(link = paste0("industry-pages-counts-2010/", state_fips, ".html")) %>%
  shift_geometry()

# -------------------- STEP 5: WHITE MASK --------------------

world_box <- st_as_sfc(st_bbox(c(xmin = -180, ymin = -90, xmax = 180, ymax = 90)), crs = 4326)
us_box <- st_as_sfc(st_bbox(c(xmin = -130, ymin = 15, xmax = -60, ymax = 55)), crs = 4326)
mask_diff <- st_difference(st_make_valid(world_box), st_make_valid(us_box))
mask_polygon <- st_collection_extract(mask_diff, "POLYGON") %>% st_make_valid()

# -------------------- STEP 6: COLOR PALETTE --------------------

set1_colors <- RColorBrewer::brewer.pal(9, "Set1")

dark2_colors <- setdiff(RColorBrewer::brewer.pal(8, "Dark2"), "#E7298A")
dark2_colors <- setdiff(dark2_colors, "#666666")

# Combine and take the first 13 distinct colors
combined_colors <- c(dark2_colors, set1_colors)[1:13]
combined_colors[c(1, 12)] <- combined_colors[c(12, 1)]
# Match with industry labels


filtered_levels <- industry_lookup$group %>% na.omit() %>% as.character() %>% sort()

filtered_colors <- setNames(combined_colors, filtered_levels)


# Step 3: Set max_industry as factor with correct levels
industry_shifted$max_industry <- factor(industry_shifted$max_industry, levels = filtered_levels)

# Step 4: Create leaflet color function
pal <- colorFactor(palette = filtered_colors, domain = filtered_levels)

# -------------------- STEP 7: RENDER MAP --------------------

industry_map <- leaflet(options = leafletOptions(
  minZoom = 4, maxZoom = 4,
  zoomControl = FALSE,
  dragging = FALSE,
  scrollWheelZoom = FALSE,
  doubleClickZoom = FALSE
)) %>%
  addTiles(urlTemplate = "") %>%
  addRectangles(-180, -90, 180, 90, fillColor = "white", fillOpacity = 1, stroke = FALSE) %>%
  addPolygons(data = mask_polygon, fillColor = "white", color = "white", weight = 0, fillOpacity = 1) %>%
  addPolygons(
    data = industry_shifted,
    fillColor = ~pal(max_industry),
    color = "white", weight = 0.3, fillOpacity = 0.9,
    label = NULL,
    highlightOptions = NULL
  ) %>%
  addPolygons(
    data = state_geom,
    fillOpacity = 0,
    color = "black", weight = 1
  ) %>%
  setView(lng = -98.5, lat = 39.8, zoom = 8)

# -------------------- STEP 8: SAVE --------------------

saveWidget(
  widget = industry_map,
  file = "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/industry2010.html",
  selfcontained = FALSE
)



```


# pie dist charts counts (fix)
```{r}

# 1. Set color palette


set1_colors <- RColorBrewer::brewer.pal(9, "Set1")

dark2_colors <- setdiff(RColorBrewer::brewer.pal(8, "Dark2"), "#E7298A")
dark2_colors <- setdiff(dark2_colors, "#666666")

# Combine and take the first 13 distinct colors
combined_colors <- c(dark2_colors, set1_colors)[1:13]
combined_colors[c(1, 12)] <- combined_colors[c(12, 1)]
# Match with industry labels


filtered_levels <- industry_lookup$group %>% na.omit() %>% as.character() %>% sort()

filtered_colors <- setNames(combined_colors, filtered_levels)


valid_inds <- names(filtered_colors)

# 2. Long-format data prep
df <- top_industry_data %>%
  st_drop_geometry() %>%
  mutate(
    county = str_remove(NAME, ",.*"),
    state_fips = str_sub(GEOID, 1, 2)
  )

industry_cols <- df %>%
  select(-GEOID, -NAME, -county, -state_fips) %>%
  select(where(is.numeric)) %>%
  names()

df_long <- df %>%
  pivot_longer(cols = all_of(industry_cols), names_to = "industry", values_to = "jobs")

# 3. Create widgets per state
for (fips in unique(df_long$state_fips)) {
  state_data <- df_long %>% filter(state_fips == fips)
  counties <- unique(state_data$county)
  pie_data <- list()

  ordered_inds <- names(filtered_colors)

  # STATEWIDE
  statewide_totals <- state_data %>%
    filter(industry %in% ordered_inds) %>%
    group_by(industry) %>%
    summarize(jobs = sum(jobs, na.rm = TRUE), .groups = "drop") %>%
    complete(industry = ordered_inds, fill = list(jobs = 0)) %>%
    arrange(factor(industry, levels = ordered_inds))

  pie_data[["Statewide"]] <- as.list(setNames(
    round(100 * statewide_totals$jobs / sum(statewide_totals$jobs), 1),
    statewide_totals$industry
  ))

  # COUNTIES
  for (cty in counties) {
    cty_totals <- state_data %>%
      filter(county == cty, industry %in% ordered_inds) %>%
      group_by(industry) %>%
      summarize(jobs = sum(jobs, na.rm = TRUE), .groups = "drop") %>%
      complete(industry = ordered_inds, fill = list(jobs = 0)) %>%
      arrange(factor(industry, levels = ordered_inds))

    pie_data[[cty]] <- as.list(setNames(
      round(100 * cty_totals$jobs / sum(cty_totals$jobs), 1),
      cty_totals$industry
    ))
  }

  pie_json <- toJSON(pie_data, auto_unbox = TRUE, pretty = FALSE)

  colors_js <- paste0(
    "const colors = {\n",
    paste(sprintf("  '%s': '%s'", names(filtered_colors), filtered_colors), collapse = ",\n"),
    "\n};"
  )

  html_page <- htmltools::HTML(glue::glue('
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Industry Composition – {fips}</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {{
      font-family: sans-serif;
      background: #fff;
    }}
    .container {{
      width: 95%;
      max-width: 1200px;
      margin: auto;
      text-align: center;
    }}
    canvas {{
  max-width: 100%;
}}
    #countySelect {{
      font-size: 1rem;
      padding: 0.5rem;
      margin-bottom: 1rem;
    }}
  </style>
</head>
<body>
  <div class="container">
    <h2>Industry Composition (Percent) – {fips}</h2>
    <select id="countySelect"></select>
    <canvas id="pieChart"></canvas>
  </div>

  <script>
    const data = {pie_json};
    {colors_js}

    const ctx = document.getElementById("pieChart").getContext("2d");
    let chart;

    function renderChart(county) {{
      const values = data[county];
      const labels = Object.keys(values);
      const percentages = Object.values(values);

      if (chart) chart.destroy();

      chart = new Chart(ctx, {{
        type: "pie",
        data: {{
          labels: labels,
          datasets: [{{
            data: percentages,
            backgroundColor: labels.map(label => colors[label] || "#cccccc")
          }}]
        }},
        options: {{
          responsive: true,
          maintainAspectRatio: true,
  aspectRatio: 1.5, // You can tweak this (e.g., 1.3, 1.5, 2)
          plugins: {{
            tooltip: {{
              callbacks: {{
                label: function(context) {{
                  return context.label + ": " + context.formattedValue + "%";
                }}
              }}
            }},
            legend: {{
              position: "right",
              labels: {{
                usePointStyle: true,
                pointStyle: "rect"
              }}
            }}
          }}
        }}
      }});
    }}

    const select = document.getElementById("countySelect");
    Object.keys(data).forEach(county => {{
      const opt = document.createElement("option");
      opt.value = county;
      opt.text = county;
      select.appendChild(opt);
    }});
    select.value = "Statewide";
    select.addEventListener("change", () => renderChart(select.value));
    renderChart("Statewide");
  </script>
</body>
</html>
'))

  save_html(html_page, file = file.path(
    "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/ind-trend-counts/",
    paste0(fips, ".html")
  ))
  cat("✅ Saved:", fips, "\n")
}



```

# pages 
```{r}


state_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/industry-pages-counts"
fips_codes <- sprintf("%02d", 1:56)  # or use unique(state_fips) if you have data

walk(fips_codes, function(fips) {
  file_path <- file.path(state_dir, paste0(fips, ".html"))

  html <- paste0(
'<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>State Page</title>
  <style>
    body {
      margin: 2rem;
      font-family: sans-serif;
    }
    #wrapper {
      display: flex;
      gap: 1rem;
      align-items: flex-start;
    }
    iframe {
      border: none;
    }
    .map-column {
      width: 60%;
    }
    .chart-column {
      width: 40%;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
  </style>
</head>
<body>
<h1>County-Level Employment by Industry - ', fips, '</h1>
  <div id="wrapper">
    <div class="map-column">
      <iframe
        src="../ind-state-maps-counts/', fips, '.html"
        title="County Map"
        style="width: 100%; height: 500px;">
      </iframe>
    </div>

    <div class="chart-column">
      <iframe
        src="../ind-trend-counts/', fips, '.html"
        title="County Table"
        style="width: 100%; height: 600px;">
      </iframe>
    </div>
  </div>
</body>
</html>'
  )

  writeLines(html, file_path)
  cat("✔️ Created:", file_path, "\n")
})


```



# children
```{r}

library(tidycensus)
library(dplyr)
library(sf)
library(stringr)
library(leaflet)
library(RColorBrewer)
library(htmlwidgets)
library(htmltools)
library(tigris)

# -------------------- STEP 1: IMPORT DATA --------------------
child_data <- get_acs(
  geography = "county",
  variables = c(with_children = "B11005_002", total = "B11005_001"),
  year = 2023,
  survey = "acs5",
  geometry = TRUE,
  cache_table = TRUE,
  cb = TRUE
) %>%
  select(GEOID, NAME, variable, estimate, geometry) %>%
  pivot_wider(names_from = variable, values_from = estimate) %>%
  mutate(
    percent_with_children = 100 * with_children / total,
    state_fips = str_sub(GEOID, 1, 2)
  ) %>%
  st_transform(4326)

# -------------------- STEP 2: STATE GEOMETRY + SHIFT --------------------
state_geom <- states(cb = TRUE, year = 2023) %>%
  filter(!STATEFP %in% c("72", "78")) %>%
  select(state_fips = STATEFP, geometry) %>%
  mutate(link = paste0("children-pages/", state_fips, ".html"))

shift_geometry <- function(sf_obj) {
  alaska <- sf_obj %>% filter(state_fips == "02") %>% st_transform(2163)
  hawaii <- sf_obj %>% filter(state_fips == "15") %>% st_transform(2163)
  mainland <- sf_obj %>% filter(!state_fips %in% c("02", "15")) %>% st_transform(4326)
  alaska_geom <- st_geometry(alaska) * 0.3 + c(-380000, -3000000)
  hawaii_geom <- st_geometry(hawaii) * 1.2 + c(4500000, -900000)
  st_crs(alaska_geom) <- 2163; st_crs(hawaii_geom) <- 2163
  alaska <- st_set_geometry(alaska, alaska_geom) %>% st_transform(4326)
  hawaii <- st_set_geometry(hawaii, hawaii_geom) %>% st_transform(4326)
  bind_rows(mainland, alaska, hawaii) %>% st_as_sf()
}

state_geom <- shift_geometry(state_geom)
child_shifted <- shift_geometry(child_data)

# -------------------- STEP 3: WHITE MASK --------------------
world_box <- st_as_sfc(st_bbox(c(xmin = -180, ymin = -90, xmax = 180, ymax = 90)), crs = 4326)
us_box <- st_as_sfc(st_bbox(c(xmin = -130, ymin = 15, xmax = -60, ymax = 55)), crs = 4326)
world_box <- st_make_valid(world_box)
us_box <- st_make_valid(us_box)
mask_diff <- st_difference(world_box, us_box)
mask_polygon <- st_collection_extract(mask_diff, "POLYGON")
st_crs(mask_polygon) <- 4326
mask_polygon <- st_make_valid(mask_polygon)
mask_polygon <- st_transform(mask_polygon, 4326)

# -------------------- STEP 4: COLOR PALETTE --------------------
valid_vals <- child_data$percent_with_children[!is.na(child_data$percent_with_children) & child_data$percent_with_children > 0]
breaks <- pretty(valid_vals)
colors <- colorRampPalette(brewer.pal(9, "PuBuGn"))(length(breaks) - 1)
pal <- colorBin(palette = colors, domain = valid_vals, bins = breaks)

# -------------------- STEP 5: LEAFLET MAP --------------------
child_map <- leaflet(options = leafletOptions(
  minZoom = 4, maxZoom = 4,
  zoomControl = FALSE,
  dragging = FALSE,
  scrollWheelZoom = FALSE,
  doubleClickZoom = FALSE
)) %>%
  addTiles(urlTemplate = "") %>%
  addRectangles(lng1 = -180, lat1 = -90, lng2 = 180, lat2 = 90, fillColor = "white", fillOpacity = 1, stroke = FALSE) %>%
  addPolygons(data = mask_polygon, fillColor = "white", color = "white", weight = 0, fillOpacity = 1) %>%
  addPolygons(
    data = child_shifted,
    fillColor = ~pal(percent_with_children),
    color = "white", weight = 0.3, fillOpacity = 0.9,
    label = ~paste0(NAME, ": ", round(percent_with_children, 1), "%"),
    highlightOptions = highlightOptions(weight = 1, color = "black", bringToFront = TRUE)
  ) %>%
  addPolygons(
    data = state_geom,
    fillOpacity = 0, color = "black", weight = 1,
    layerId = ~link,
    highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
  ) %>%
  addLegend(
    position = "topright",
    colors = colors,
    labels = paste0(formatC(breaks[-length(breaks)], format = "d"), "%"),
    title = "% of Households with Children Under 18",
    opacity = 1
  ) %>%
  setView(lng = -98.5, lat = 39.8, zoom = 8)

# -------------------- STEP 6: CLICK BEHAVIOR --------------------
child_map <- onRender(child_map, "
  function(el, x) {
    var map = this;
    var hash = window.location.hash;
    map.eachLayer(function(layer) {
      if (layer.options && layer.options.layerId) {
        layer.on('click', function(e) {
          window.top.location.href = layer.options.layerId + hash;
        });
      }
    });
  }
")

# -------------------- STEP 7: SAVE --------------------
saveWidget(
  widget = child_map,
  file = '/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/children.html',
  selfcontained = FALSE
)



# state maps 


unique_states <- unique(earnings_data$state_fips)

walk(unique_states, function(fips) {
  state_data <- child_data %>%
    filter(state_fips == fips)

  if (nrow(state_data) == 0 || all(is.na(state_data$geometry))) return(NULL)

  # Step 1: Determine data range for this state
  range_vals <- range(state_data$percent_with_children, na.rm = TRUE)

  # Step 2: Generate "nice" breaks dynamically
 raw_breaks <- quantile(state_data$percent_with_children, probs = seq(0, 1, length.out = 6), na.rm = TRUE)
breaks <- pretty(raw_breaks)



  # Step 3: Create color palette function
  pal <- colorBin(
  palette = "PuBuGn",
  domain = state_data$percent_with_children,
  bins = breaks,
  pretty = FALSE
)

  # Step 4: Build leaflet map
  leaflet_map <- leaflet(state_data, options = leafletOptions(minZoom = 4, maxZoom = 8)) %>%
    addProviderTiles("CartoDB.PositronNoLabels") %>%
    addPolygons(
      fillColor = ~pal(percent_with_children),
      fillOpacity = 0.9,
      color = "white",
      weight = 1,
      label = ~paste0(NAME, ": ", round(percent_with_children, 1), '%'),
      highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
    ) %>%
    addLegend(
      position = "topright",
      pal = pal,
      values = state_data$percent_with_children,
      title = "% of Households With Children Under 18",
      opacity = 1
    )

  # Step 5: Save map
  saveWidget(
    widget = leaflet_map,
    file = paste0(
      "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/child-maps/",
      fips, ".html"
    ),
    selfcontained = FALSE
  )
})





# age dist chart 
library(tidycensus)
library(dplyr)
library(tidyr)
library(stringr)


output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/age-children/"
dir.create(output_dir, showWarnings = FALSE)
acs_vars <- load_variables(2023, "acs5", cache = TRUE)
age_map <- tibble(
  code = c(3:6, 27:30),
  gender = rep(c("Male", "Female"), each = 4),
  age_group = rep(c("0–4", "5–9", "10–14", "15–17"), times = 2),
  bin = rep(c("0–4", "5–9", "10–14", "15–17"), times = 2),
  variable = sprintf("B01001_%03d", code)
)

age_bins <- c("0–4", "5–9", "10–14", "15–17")

# --------------------- PULL DATA ---------------------
age_data <- get_acs(
  geography = "county",
  variables = unique(age_map$variable),
  year = 2023,
  survey = "acs5"
)

# --------------------- PROCESS ---------------------
age_clean <- age_data %>%
  left_join(age_map, by = "variable")

under18_totals <- age_clean %>%
  group_by(GEOID) %>%
  summarise(under18_total = sum(estimate, na.rm = TRUE), .groups = "drop")

age_clean <- age_clean %>%
  left_join(under18_totals, by = "GEOID") %>%
  mutate(
    percent = 100 * estimate / under18_total,
    state_fips = str_sub(GEOID, 1, 2)
  ) %>%
  select(GEOID, NAME, gender, bin, estimate, under18_total, percent, state_fips)

# --------------------- LOOKUP TABLE ---------------------
state_lookup <- age_clean %>%
  mutate(state_name = str_trim(str_extract(NAME, "(?<=, ).*"))) %>%
  distinct(state_fips, state_name)

# --------------------- LOOP BY STATE ---------------------
for (state in unique(age_clean$state_fips)) {
  state_data <- age_clean %>% filter(state_fips == !!state)

  state_name <- state_data$NAME %>%
    str_extract("[^,]+$") %>%
    unique()

  total_state_pop <- state_data %>%
    distinct(GEOID, under18_total) %>%
    summarise(total = sum(under18_total, na.rm = TRUE)) %>%
    pull(total)

  statewide <- state_data %>%
    group_by(gender, bin) %>%
    summarise(estimate = sum(estimate, na.rm = TRUE), .groups = "drop") %>%
    mutate(percent = round(100 * estimate / total_state_pop, 1)) %>%
    mutate(percent = ifelse(gender == "Male", -percent, percent)) %>%
    select(bin, gender, percent)

  counties <- unique(state_data$NAME)
  json_data <- list()

  # Add statewide to JSON
  json_data$Statewide <- setNames(
    as.numeric(t(cbind(
      statewide %>% filter(gender == "Male") %>% pull(percent),
      statewide %>% filter(gender == "Female") %>% pull(percent)
    ))),
    as.vector(outer(c("Male", "Female"), age_bins, paste))
  )

  # Add counties
  for (county in counties) {
    sub <- state_data %>% filter(NAME == county)
    row <- sub %>%
      group_by(gender, bin) %>%
      summarise(percent = sum(percent, na.rm = TRUE), .groups = "drop") %>%
      mutate(percent = ifelse(gender == "Male", -round(percent, 1), round(percent, 1))) %>%
      pivot_wider(names_from = gender, values_from = percent) %>%
      complete(bin = age_bins, fill = list(Male = 0, Female = 0)) %>%
      arrange(factor(bin, levels = age_bins)) %>%
      select(Male, Female)

    json_data[[county]] <- setNames(
      as.numeric(t(cbind(row$Male, row$Female))),
      as.vector(outer(c("Male", "Female"), age_bins, paste))
    )
  }

  # --------------------- HTML OUTPUT ---------------------
  html <- tags$html(
    tags$head(
      tags$meta(charset = "UTF-8"),
      tags$title(paste("Age Distribution Under 18 –", state_name)),
      tags$script(src = "https://cdn.jsdelivr.net/npm/chart.js"),
      tags$style(HTML("
        body {
          font-family: sans-serif;
          margin: 1rem 2rem;
          text-align: center;
        }
        h2 {
          margin-bottom: 0.25rem;
          font-size: 1.6rem;
        }
        select {
          padding: 0.4rem;
          font-size: 1rem;
          margin: 1rem 0;
          border-radius: 5px;
          border: 1px solid #999;
        }
        canvas {
          width: 100%;
          max-width: 850px;
          height: 500px;
          margin-top: 1rem;
        }
      "))
    ),
    tags$body(
      tags$h2(paste("Age Distribution Under 18 in", state_name, "(2023)")),
      tags$label("Select County:"),
      HTML(glue('
        <select id="countySelect">
          {paste0("<option value=\'", c("Statewide", sort(counties)), "\'>", c("Statewide", sort(counties)), "</option>", collapse = "\n")}
        </select>
      ')),
      tags$canvas(id = "barChart", width = 850, height = 500),
      tags$script(HTML(glue("
        const ageData = {toJSON(json_data, auto_unbox=TRUE)};
        const ageBins = {toJSON(age_bins, auto_unbox=TRUE)};
        const ctx = document.getElementById('barChart').getContext('2d');
        let chart;

        function renderChart(data) {{
          const maleData = data.filter((_, i) => i % 2 === 0);
          const femaleData = data.filter((_, i) => i % 2 === 1);

          const maxValue = Math.max(
            ...maleData.map(Math.abs),
            ...femaleData.map(Math.abs)
          );
          const padding = 1.0;
          const xMax = +(maxValue + padding).toFixed(1);

          if (chart) chart.destroy();
          chart = new Chart(ctx, {{
            type: 'bar',
            data: {{
              labels: ageBins,
              datasets: [
                {{
                  label: 'Male',
                  data: maleData,
                  backgroundColor: 'dodgerblue'
                }},
                {{
                  label: 'Female',
                  data: femaleData,
                  backgroundColor: 'lightpink'
                }}
              ]
            }},
            options: {{
              indexAxis: 'y',
              responsive: true,
              scales: {{
                x: {{
                  min: -xMax,
                  max: xMax,
                  ticks: {{
                    callback: value => Math.abs(value).toFixed(1) + '%'
                  }}
                }},
                y: {{
                  stacked: false
                }}
              }},
              plugins: {{
                legend: {{
                  position: 'top',
                  align: 'start',
                  labels: {{
                    usePointStyle: true
                  }}
                }},
                tooltip: {{
                  callbacks: {{
                    label: ctx => ctx.dataset.label + ': ' + Math.abs(ctx.parsed.x).toFixed(1) + '%'
                  }}
                }}
              }}
            }}
          }});
        }}

        document.getElementById('countySelect').addEventListener('change', function() {{
          renderChart(Object.values(ageData[this.value]));
        }});

        renderChart(Object.values(ageData['Statewide']));
      ")))
    )
  )

  save_html(html, file = file.path(output_dir, paste0(state, ".html")))
  cat("✅ Saved widget for", state_name, "\n")
}






# PAGES 


input_map_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/child-maps"
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/children-pages/"
input_table_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/age-children"

# List HTML files
fips_list <- dir_ls(input_map_dir, regexp = "\\.html$") %>% path_file() %>% path_ext_remove()

walk(fips_list, function(fips_code) {
  table_path <- file.path(input_table_dir, paste0(fips_code, ".html"))
  map_src <- glue("../child-maps/{fips_code}.html")

  # Read just the <table> from the existing HTML file

  html_content <- glue('
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Children – State {fips_code}</title>
  <style>
    body {{
      margin: 0;
      padding: 2rem;
      font-family: sans-serif;
      background-color: #f9f9f9;
    }}
    h1 {{
      font-size: 1.5rem;
      margin-bottom: 1.5rem;
    }}
    .container {{
      display: flex;
      gap: 2rem;
    }}
    .map {{
      flex: 1;
    }}
    .table-box {{
      flex: 1;
      background-color: white;
      padding: 1rem;
      border: 1px solid #ccc;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      overflow-x: auto;
    }}
    iframe {{
      width: 100%;
      height: 550px;
      border: none;
    }}
    table {{
      font-size: 0.95rem;
      border-collapse: collapse;
      width: 100%;
    }}
    th, td {{
      padding: 6px;
      border: 1px solid #ccc;
      text-align: left;
    }}
    th {{
      background-color: #f0f0f0;
    }}
  </style>
</head>
<body>

  <h1> % of Households With Children Under 18 – {fips_code} (2023)</h1>

  <div class="container">
    <div class="map">
      <iframe src="{map_src}" title="Chidren Map – {fips_code}"></iframe>
    </div>
    <div class="table-box">
      <div><strong>Age Dist by County</strong></div>
      <iframe src="../age-children/{fips_code}.html" title=" Age Chart – {fips_code}"></iframe>
    </div>
  </div>

</body>
</html>
')

  write_file(html_content, path(output_dir, paste0(fips_code, ".html")))
})



```


# veteran 
```{r}

veteran_data <- get_acs(
  geography = "county",
  variables = c(
    total = "B21001_001",
    veteran = "B21001_002"
  ),
  year = 2023,
  survey = "acs5",
  geometry = TRUE
)

veteran_clean <- veteran_data %>%
  select(GEOID, NAME, variable, estimate, geometry) %>%
  pivot_wider(names_from = variable, values_from = estimate) %>%
  mutate(
    pct_veteran = veteran / total,
    state_fips = substr(GEOID, 1, 2)
  )

# -------------------- 2. SHIFT GEOMETRY --------------------
shift_geometry <- function(sf_obj) {
  alaska <- sf_obj %>% filter(state_fips == "02") %>% st_transform(2163)
  hawaii <- sf_obj %>% filter(state_fips == "15") %>% st_transform(2163)
  mainland <- sf_obj %>% filter(!state_fips %in% c("02", "15")) %>% st_transform(4326)
  alaska_geom <- st_geometry(alaska) * 0.3 + c(-380000, -3000000)
  hawaii_geom <- st_geometry(hawaii) * 1.2 + c(4500000, -900000)
  st_crs(alaska_geom) <- 2163; st_crs(hawaii_geom) <- 2163
  alaska <- st_set_geometry(alaska, alaska_geom) %>% st_transform(4326)
  hawaii <- st_set_geometry(hawaii, hawaii_geom) %>% st_transform(4326)
  bind_rows(mainland, alaska, hawaii) %>% st_as_sf()
}

veteran_shifted <- shift_geometry(veteran_clean)

# -------------------- 3. STATE GEOMETRY --------------------
state_geom_veteran <- states(cb = TRUE, year = 2023) %>%
  filter(!STATEFP %in% c("72", "78")) %>%
  select(state_fips = STATEFP, geometry) %>%
  mutate(link = paste0("veteran-pages/", state_fips, ".html"))

state_geom_veteran <- shift_geometry(state_geom_veteran)

# -------------------- 4. WHITE MASK --------------------
world_box <- st_as_sfc(st_bbox(c(xmin = -180, ymin = -90, xmax = 180, ymax = 90)), crs = 4326)
us_box <- st_as_sfc(st_bbox(c(xmin = -130, ymin = 15, xmax = -60, ymax = 55)), crs = 4326)
mask_polygon <- st_difference(st_make_valid(world_box), st_make_valid(us_box)) %>%
  st_collection_extract("POLYGON") %>%
  st_set_crs(4326)

# -------------------- 5. MAP SETUP --------------------
vals <- veteran_shifted$pct_veteran
max_val <- max(vals, na.rm = TRUE)

breaks <- seq(0, ceiling(max_val * 100) / 100, length.out = 11)
colors <- colorRampPalette(brewer.pal(9, "BuGn"))(length(breaks) - 1)
pal <- colorBin(colors, domain = vals, bins = breaks)

veteran_map <- leaflet(options = leafletOptions(
  minZoom = 4, maxZoom = 4,
  zoomControl = FALSE, dragging = FALSE,
  scrollWheelZoom = FALSE, doubleClickZoom = FALSE
)) %>%
  addTiles(urlTemplate = "") %>%
  addRectangles(lng1 = -180, lat1 = -90, lng2 = 180, lat2 = 90,
                fillColor = "white", fillOpacity = 1, stroke = FALSE) %>%
  addPolygons(data = mask_polygon, fillColor = "white", color = "white", weight = 0, fillOpacity = 1) %>%
  addPolygons(
    data = veteran_shifted,
    fillColor = ~pal(pct_veteran),
    color = "white", weight = 0.3, fillOpacity = 0.9,
    label = ~paste0(NAME, ": ", round(pct_veteran * 100, 1), "%"),
    highlightOptions = highlightOptions(weight = 1, color = "black", bringToFront = TRUE)
  ) %>%
  addPolygons(
    data = state_geom_veteran,
    fillOpacity = 0, color = "black", weight = 1,
    layerId = ~link,
    highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
  ) %>%
  addLegend(
    position = "topright", colors = colors,
    labels = paste0(round(breaks[-length(breaks)] * 100), "%"),
    title = "Veterans (2023)", opacity = 1
  ) %>%
  setView(lng = -98.5, lat = 39.8, zoom = 8)

# -------------------- 6. JS CLICK HANDLER --------------------
veteran_map <- onRender(veteran_map, "
  function(el, x) {
    var map = this;
    var hash = window.location.hash;
    map.eachLayer(function(layer) {
      if (layer.options && layer.options.layerId) {
        layer.on('click', function(e) {
          window.top.location.href = layer.options.layerId + hash;
        });
      }
    });
  }
")

# -------------------- 7. SAVE --------------------
saveWidget(
  widget = veteran_map,
  file = "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/veteran-map.html",
  selfcontained = FALSE
)


# state maps 



unique_states <- unique(veteran_clean$state_fips)

walk(unique_states, function(fips) {
  state_data <- veteran_clean %>%
    filter(state_fips == fips)

  if (nrow(state_data) == 0 || all(is.na(state_data$geometry))) return(NULL)

  # Step 1: Determine data range for this state
  range_vals <- range(state_data$pct_veteran, na.rm = TRUE)

  # Step 2: Generate "nice" breaks dynamically
 raw_breaks <- quantile(state_data$pct_veteran, probs = seq(0, 1, length.out = 6), na.rm = TRUE)
breaks <- pretty(raw_breaks)



  # Step 3: Create color palette function
  pal <- colorBin(
  palette = "BuGn",
  domain = state_data$pct_veteran,
  bins = breaks,
  pretty = FALSE
)

  # Step 4: Build leaflet map
  leaflet_map <- leaflet(state_data, options = leafletOptions(minZoom = 4, maxZoom = 8)) %>%
    addProviderTiles("CartoDB.PositronNoLabels") %>%
    addPolygons(
      fillColor = ~pal(pct_veteran),
      fillOpacity = 0.9,
      color = "white",
      weight = 1,
      label = ~paste0(NAME, ": ", round(pct_veteran * 100, 1), '%'),
      highlightOptions = highlightOptions(weight = 2, color = "black", bringToFront = TRUE)
    ) %>%
    addLegend(
  position = "topright",
  pal = pal,
  values = state_data$pct_veteran,
  title = "Share of Adults Who Are Veterans (2023)",
  opacity = 1,
  labFormat = labelFormat(
    suffix = "%",
    transform = function(x) 100 * x  # Convert proportions to percents
  )
)

  # Step 5: Save map
  saveWidget(
    widget = leaflet_map,
    file = paste0(
      "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/vet-maps/",
      fips, ".html"
    ),
    selfcontained = FALSE
  )
})








# labor charts 
labor_vars <- c(
  "B21005_005", "B21005_016", "B21005_027",  # Employed
  "B21005_006", "B21005_017", "B21005_028",  # Unemployed
  "B21005_007", "B21005_018", "B21005_029"   # Not in labor force
)
categories <- c("Employed", "Unemployed", "Not in Labor Force")
output_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/vet-charts"
dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)

# National baseline
us_raw <- get_acs(geography = "us", variables = labor_vars, year = 2023, survey = "acs5")
us_clean <- us_raw %>%
  mutate(status = case_when(
    variable %in% c("B21005_005", "B21005_016", "B21005_027") ~ "Employed",
    variable %in% c("B21005_006", "B21005_017", "B21005_028") ~ "Unemployed",
    variable %in% c("B21005_007", "B21005_018", "B21005_029") ~ "Not in Labor Force"
  )) %>%
  group_by(status) %>%
  summarise(national_percent = sum(estimate), .groups = "drop") %>%
  mutate(national_percent = round(100 * national_percent / sum(national_percent), 1))
national_avg <- setNames(us_clean$national_percent, us_clean$status)

# FIPS lookup
fips_lookup <- tidycensus::fips_codes %>%
  filter(state_code %in% sprintf("%02d", 1:56)) %>%
  distinct(state_code, state_name) %>%
  group_by(state_code) %>%
  slice(1) %>%
  ungroup() %>%
  mutate(fips = state_code)

# Loop per state
for (fips in fips_lookup$fips) {
  state_name <- fips_lookup$state_name[fips_lookup$fips == fips]
  message("Working on: ", state_name)

  county_raw <- get_acs(
    geography = "county", state = fips,
    variables = labor_vars, year = 2023, survey = "acs5"
  )

  labor_clean <- county_raw %>%
    mutate(status = case_when(
      variable %in% c("B21005_005", "B21005_016", "B21005_027") ~ "Employed",
      variable %in% c("B21005_006", "B21005_017", "B21005_028") ~ "Unemployed",
      variable %in% c("B21005_007", "B21005_018", "B21005_029") ~ "Not in Labor Force"
    )) %>%
    group_by(NAME, status) %>%
    summarise(total = sum(estimate), .groups = "drop") %>%
    group_by(NAME) %>%
    mutate(percent = round(100 * total / sum(total), 1)) %>%
    ungroup()

  counties <- unique(labor_clean$NAME)
  json_data <- list()

  # Statewide totals
  statewide <- labor_clean %>%
    group_by(status) %>%
    summarise(total = sum(total), .groups = "drop") %>%
    mutate(percent = round(100 * total / sum(total), 1)) %>%
    arrange(factor(status, levels = categories))
  json_data$Statewide <- setNames(statewide$percent, categories)

  # County-level data
  for (county in counties) {
    this <- labor_clean %>%
      filter(NAME == county) %>%
      arrange(factor(status, levels = categories))
    json_data[[county]] <- setNames(this$percent, categories)
  }

  # HTML widget
  html <- tags$html(
    tags$head(
      tags$meta(charset = "UTF-8"),
      tags$title(paste("Veteran Labor Force Status –", state_name)),
      tags$script(src = "https://cdn.jsdelivr.net/npm/chart.js"),
      tags$style(HTML("
        body { font-family: sans-serif; margin: 1rem 2rem; text-align: center; }
        h2 { margin-bottom: 0.25rem; font-size: 1.6rem; }
        select { padding: 0.4rem; font-size: 1rem; margin: 1rem 0; }
        canvas { width: 100%; max-width: 850px; height: 500px; }
      "))
    ),
    tags$body(
      tags$h2(paste("Labor Force Status of Veterans (Age 18–64) in", state_name)),
      tags$label("Select County:"),
      tags$select(
        id = "countySelect",
        tags$option(value = "Statewide", "Statewide"),
        lapply(sort(counties), function(x) tags$option(value = x, x))
      ),
      tags$canvas(id = "barChart"),
      tags$script(HTML(glue('
        const data = {toJSON(json_data, auto_unbox = TRUE)};
        const nationalAvg = {toJSON(national_avg, auto_unbox = TRUE)};
        const categories = {toJSON(categories, auto_unbox = TRUE)};
        const ctx = document.getElementById("barChart").getContext("2d");
        let chart;

        function renderChart(values) {{
          if (chart) chart.destroy();
          chart = new Chart(ctx, {{
            type: "bar",
            data: {{
              labels: categories,
              datasets: [
                {{
                  label: "County/State",
                  data: values,
                  backgroundColor: ["#66c2a5", "#fc8d62", "#8da0cb"]
                }},
                {{
                  label: null,
                  data: categories.map(c => nationalAvg[c]),
                  type: "line",
                  borderColor: "black",
                  borderWidth: 2,
                  pointRadius: 0,
                  fill: false
                }}
              ]
            }},
            options: {{
              indexAxis: "y",
              scales: {{
                x: {{
                  min: 0,
                  max: 100,
                  ticks: {{
                    callback: v => v + "%"
                  }}
                }}
              }},
              plugins: {{
                legend: {{
  display: false
}},
                tooltip: {{
                  callbacks: {{
                    label: ctx => ctx.dataset.label ? ctx.dataset.label + ": " + ctx.raw + "%" : null
                  }}
                }}
              }}
            }}
          }});
        }}

        document.getElementById("countySelect").addEventListener("change", function() {{
          renderChart(Object.values(data[this.value]));
        }});

        renderChart(Object.values(data["Statewide"]));
      ')))
    )
  )

  save_html(html, file = file.path(output_dir, paste0(fips, ".html")))
  cat("✅ Saved widget for", state_name, "\n")
}




# pages 


state_dir <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/misc/veteran-pages/"
fips_codes <- sprintf("%02d", 1:56)  # or use unique(state_fips) if you have data

walk(fips_codes, function(fips) {
  file_path <- file.path(state_dir, paste0(fips, ".html"))

  html <- paste0(
'<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>State Page</title>
  <style>
    body {
      margin: 2rem;
      font-family: sans-serif;
    }
    #wrapper {
      display: flex;
      gap: 1rem;
      align-items: flex-start;
    }
    iframe {
      border: none;
    }
    .map-column {
      width: 60%;
    }
    .chart-column {
      width: 40%;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
  </style>
</head>
<body>
<h1>Veteran Status by County - ', fips, '</h1>
  <div id="wrapper">
    <div class="map-column">
      <iframe
        src="../vet-maps/', fips, '.html"
        title="County Map"
        style="width: 100%; height: 500px;">
      </iframe>
    </div>

    <div class="chart-column">
      <iframe
        src="../vet-charts/', fips, '.html"
        title="County Table"
        style="width: 100%; height: 600px;">
      </iframe>
    </div>
  </div>
</body>
</html>'
  )

  writeLines(html, file_path)
  cat("✔️ Created:", file_path, "\n")
})



```

# general style fix 


```{r}
library(xml2)
library(stringr)
library(glue)
library(rvest)
library(fs)

# Folder with HTML files to restyle
folder_path <- "/Users/theoweinstock/University of Michigan Dropbox/Theo Weinstock/SSDAN/ssdan-mapping/maps/earnings-pages"
html_files <- dir_ls(folder_path, regexp = "\\d{2}\\.html$")

# New CSS styles
html_files <- list.files(folder_path, pattern = "^\\d{2}\\.html$", full.names = TRUE)

new_css <- '
  body {
    margin: 2rem;
    font-family: sans-serif;
    background-color: #f8f9fa;
  }
  h1 {
    font-size: 1.6rem;
    margin-bottom: 1.5rem;
    color: #333;
  }
  .grid-container {
    display: flex;
    gap: 1.5rem;
    align-items: flex-start;
  }
  .panel {
    flex: 1;
    background: white;
    padding: 1rem;
     border: 2px solid #676da7;
    border-radius: 10px;
    box-shadow: 0 0 8px rgba(0,0,0,0.08);
  }
  iframe {
    width: 100%;
    height: 600px;
    border: none;
    border-radius: 8px;
  }
'

for (file in html_files) {
  # Skip if file is empty
  if (file.info(file)$size == 0) {
    message("⚠️ Skipping empty file: ", basename(file))
    next
  }

  html <- tryCatch(read_html(file), error = function(e) NULL)

  if (is.null(html)) {
    message("⚠️ Skipping unreadable file: ", basename(file))
    next
  }

  # Get title and h1
  page_title <- html %>% html_element("title") %>% html_text(trim = TRUE)
  heading <- html %>% html_element("h1") %>% html_text(trim = TRUE)

  # Get all iframe elements
  iframes <- html %>% html_elements("iframe")

  if (length(iframes) < 2) {
    message("⚠️ Skipping (less than 2 iframes): ", basename(file))
    next
  }

  # Rebuild new HTML structure
  new_html <- glue('
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>{page_title}</title>
  <style>{new_css}</style>
</head>
<body>

  <h1>{heading}</h1>

  <div class="grid-container">
    <div class="panel">
      {as.character(iframes[1])}
    </div>
    <div class="panel">
      {as.character(iframes[2])}
    </div>
  </div>

</body>
</html>
')

  write_file(new_html, file)
  message("✅ Restyled: ", basename(file))
}



```



